<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Interaction Insights - By IPI</title>
  <style>
    :root{
      --primary-color:#63AB8F; --secondary-color:#4A8C7D; --border-color:#DEE2E6;
      --light-bg:#F8F9FA; --card-bg:#FFFFFF; --text-color:#2C3E50; --text-light:#6C757D;
      --pill:#e9f6f0;
    }
    body{font-family:"Aptos","Segoe UI",Arial,sans-serif;margin:20px;padding:20px;max-width:1400px;background:var(--light-bg);color:var(--text-color)}
    #logo-container{text-align:center;margin-bottom:20px} #logo{width:300px}
    h1{margin:0 0 16px}
    .card{background:var(--card-bg);border:1px solid var(--border-color);border-radius:12px;padding:24px;margin-top:16px;box-shadow:0 1px 3px rgba(0,0,0,.1)}
    label{display:block;font-weight:600;margin-bottom:6px}
    select,input,button{padding:10px;border:1px solid var(--border-color);border-radius:6px;background:var(--card-bg);font-size:14px}
    button{background:var(--primary-color);color:#fff;font-weight:600;cursor:pointer;transition:background .2s}
    button:hover{background:var(--secondary-color)} button:disabled{background:var(--text-light);cursor:not-allowed}
    .controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:20px 24px;align-items:start}
    .inline{display:grid;grid-template-columns:1fr auto 1fr;gap:16px;align-items:center} .inline span{color:var(--text-light)}
    .full-width-btn{width:100%;padding:14px 18px;font-size:16px;margin-top:12px}
    .muted{color:var(--text-light)} .mono{font-family:ui-monospace,Consolas,Menlo,monospace}
    .user-info,.conversation-header,.transcript-summary{background:transparent;border:2px solid var(--primary-color);border-radius:10px;padding:16px;margin:12px 0}
    details{background:var(--light-bg);border:1px solid var(--border-color);border-radius:8px;padding:16px;margin:12px 0}
    details>summary{cursor:pointer;font-weight:600}
    pre{background:#1f2937;color:#f3f4f6;padding:16px;border-radius:6px;overflow:auto;font-size:12px}
    .stats{display:flex;gap:16px;margin:16px 0}
    .stat-card{flex:1;border:1px solid var(--border-color);border-radius:8px;padding:16px;text-align:center;background:var(--card-bg)}
    .stat-number{font-size:22px;color:#63AB8F;font-weight:700}
    .journey-timeline{margin:20px 0 8px;padding-left:20px;border-left:3px solid var(--primary-color)}
    .journey-step{margin-bottom:18px;position:relative}
    .journey-step:before{content:'';position:absolute;left:-26px;top:0;width:16px;height:16px;border-radius:50%;background:var(--primary-color)}
    .step-header{font-weight:700;color:var(--secondary-color);margin-bottom:8px}
    .step-details{background:var(--card-bg);border:1px solid var(--border-color);border-radius:6px;padding:12px}
    .info-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:12px}
    .info-item{display:flex;justify-content:space-between;border-bottom:1px solid var(--border-color);padding:6px 0}
    .info-label{font-weight:600;min-width:150px}
    .participant-badge{display:inline-block;padding:4px 8px;border-radius:4px;font-size:12px;font-weight:600;margin:2px;border:1px solid var(--border-color);background:#fff}
    .badge-customer{border-color:#a7e3c6;color:#1f7255}
    .badge-agent{background:#dbeafe;color:#1e40af}
    .badge-queue{background:#fde7ff;color:#7c3aed}
    .transfer-info{background:#fff7ed;border:1px solid var(--border-color);border-radius:6px;padding:8px;margin:8px 0}
    .transfer-count{background:#fee2e2;color:#b91c1c;padding:2px 8px;border-radius:6px;font-weight:700}
    .progress-bar{width:100%;height:8px;background:var(--border-color);border-radius:4px;overflow:hidden;margin:10px 0}
    .progress-fill{height:100%;background:var(--primary-color);transition:width .3s}
    .t-summary-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:10px 16px}
    .t-kv{display:flex;gap:10px;justify-content:space-between}.t-kv .k{font-weight:700}
    .pill{display:inline-block;background:var(--pill);border:1px solid var(--border-color);border-radius:999px;padding:2px 8px;font-size:12px;margin-right:6px}
    .transcript-table{width:100%;border-collapse:collapse;margin-top:10px}
    .transcript-table th,.transcript-table td{border-bottom:1px solid var(--border-color);padding:8px 10px;vertical-align:top}
    .transcript-table th{background:var(--primary-color);color:#fff;text-align:left}
    .sentiment-positive{color:#16a34a;font-weight:700}
    .sentiment-negative{color:#dc2626;font-weight:700}
    .sentiment-neutral{color:#f59e0b;font-weight:700}
    .empathy-positive{color:#16a34a;font-weight:700}
    .empathy-negative{color:#dc2626;font-weight:700}
    .confidence-high{color:#16a34a;font-weight:700}
    .confidence-medium{color:#f59e0b;font-weight:700}
    .confidence-low{color:#dc2626;font-weight:700}
    .loading{opacity:.6;pointer-events:none}
    .future-date{color:#ccc;cursor:not-allowed}
    
    .tab-container { margin-top: 20px; }
    .tab-buttons { display: flex; border-bottom: 1px solid var(--border-color); margin-bottom: 20px; }
    .tab-button { padding: 10px 20px; background: none; border: none; cursor: pointer; font-weight: 600; color: var(--text-light); border-bottom: 3px solid transparent; transition: all 0.2s; }
    .tab-button.active { color: var(--primary-color); border-bottom-color: var(--primary-color); }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    
    .transfer-table { width: 100%; border-collapse: collapse; margin-top: 16px; }
    .transfer-table th, .transfer-table td { border: 1px solid var(--border-color); padding: 12px; text-align: left; }
    .transfer-table th { background-color: var(--primary-color); color: white; font-weight: 600; }
    .transfer-table tr:nth-child(even) { background-color: var(--light-bg); }
    .transfer-table tr:hover { background-color: #f0f7f4; }
    
    .transfer-stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 20px; }
    .transfer-stat-card { background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 16px; text-align: center; }
    .transfer-stat-number { font-size: 24px; color: var(--primary-color); font-weight: 700; margin-bottom: 8px; }
    .transfer-stat-label { font-size: 14px; color: var(--text-light); }
    
    .filter-controls { display: flex; gap: 12px; margin-bottom: 16px; flex-wrap: wrap; }
    .filter-controls select, .filter-controls input { flex: 1; min-width: 150px; }
    
    .queue-transfer-matrix { overflow-x: auto; margin-top: 20px; }
    .matrix-table { border-collapse: collapse; width: 100%; min-width: 600px; }
    .matrix-table th, .matrix-table td { border: 1px solid var(--border-color); padding: 10px; text-align: center; }
    .matrix-table th { background-color: var(--primary-color); color: white; font-weight: 600; }
    .matrix-table th.from-header { background-color: var(--secondary-color); }
    .matrix-table th.to-header { background-color: var(--primary-color); }
    .matrix-table td.from-label { background-color: var(--light-bg); font-weight: 600; text-align: left; }
    .matrix-table tr:hover td { background-color: #f0f7f4; }
    .matrix-count { font-weight: 600; color: var(--text-color); }
    .matrix-high { background-color: #fee2e2 !important; }
    .matrix-medium { background-color: #fef3c7 !important; }
    .matrix-low { background-color: #d1fae5 !important; }
    
    .conversation-transfer-group { 
      border: 1px solid var(--border-color);
      border-radius: 8px;
      margin-bottom: 12px;
      overflow: hidden;
    }
    .conversation-transfer-header { 
      background-color: var(--light-bg);
      padding: 12px 16px;
      cursor: pointer;
      display: flex;
      justify-content:space-between;
      align-items:center;
      font-weight:600;
    }
    .conversation-transfer-count {
      background-color: var(--primary-color);
      color: white;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 12px;
      margin-left: 8px;
    }
    .conversation-transfer-details {
      display: none;
      background-color: white;
    }
    .conversation-transfer-details.open {
      display: block;
    }
    .transfer-leg {
      padding: 10px 16px;
      border-bottom: 1px solid var(--light-bg);
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .transfer-leg:last-child {
      border-bottom: none;
    }
    .transfer-leg-number {
      background-color: var(--light-bg);
      color: var(--text-color);
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 600;
    }
    .transfer-leg-content {
      flex: 1;
    }
    .transfer-leg-arrow {
      color: var(--primary-color);
      font-weight: 600;
      margin: 0 8px;
    }
    
    .agent-selector { margin-bottom: 16px; }
    .agent-selector label { display: inline-block; margin-right: 12px; }
    .agent-selector select { min-width: 200px; }
  </style>
</head>
<body>
  <div id="logo-container">
    <img id="logo" src="https://raw.githubusercontent.com/gmcglynn88/ExternalWorkCreation/main/Consultinglogo.png" alt="Company Logo">
  </div>
  <h1>Interaction Insights - By IPI</h1>
  <button id="signinBtn" style="display:none;margin-bottom:12px;">Sign in to Genesys Cloud</button>

  <div id="authStatus" class="card" style="display:none;">
    <div style="text-align:center;padding:20px;">
      <div style="font-size:18px;color:var(--secondary-color);margin-bottom:8px;">üîê Authenticating‚Ä¶</div>
      <div class="muted">Connecting to Genesys Cloud</div>
    </div>
  </div>

  <div id="mainContent" style="display:none;">
    <div class="card">
      <h2 style="margin:0 0 12px;">Select Agent & Date Range</h2>
      <div class="controls">
        <div>
          <label for="agentSelect">Select Agent</label>
          <select id="agentSelect"><option>Loading users‚Ä¶</option></select>
          <input id="agentFilter" type="text" placeholder="Filter users by name" style="margin-top:8px"/>
          <div class="user-info" id="selectedAgentInfo" style="display:none;">
            <strong>Selected Agent:</strong> <span id="selectedAgentName">None</span>
          </div>
        </div>
        <div>
          <label>Date Range</label>
          <div class="inline">
            <input id="fromDate" type="date"/>
            <span>to</span>
            <input id="toDate" type="date"/>
          </div>
          <label style="display:flex;align-items:center;gap:8px;margin-top:8px;">
            <input id="autoChunk" type="checkbox" checked/> Auto-split large date ranges (recommended)
          </label>
        </div>
      </div>
      <button id="fetchBtn" class="full-width-btn">Fetch Conversations</button>
    </div>

    <div id="statusMessage" class="muted" style="margin-top:10px;"></div>
    <div id="errorMessage" style="color:#dc2626;margin-top:6px;"></div>

    <div id="progressSection" style="display:none;">
      <div class="card">
        <h3 style="margin:0 0 8px;">Fetching Conversations</h3>
        <div class="muted" id="chunkInfo">Processing date range in smaller chunks‚Ä¶</div>
        <div class="progress-bar"><div class="progress-fill" id="progressFill" style="width:0%"></div></div>
        <div style="display:flex;justify-content:space-between;font-size:14px" class="muted">
          <span id="progressText">0%</span><span id="chunkText">Chunk 0/0</span>
        </div>
      </div>
    </div>

    <div class="tab-container">
      <div class="tab-buttons">
        <button class="tab-button active" data-tab="conversations">Conversations</button>
        <button class="tab-button" data-tab="transfers">Transfer Reporting</button>
        <button class="tab-button" data-tab="queue-transfer-matrix">Queue Transfer Matrix</button>
        <button class="tab-button" data-tab="agent-transfer-matrix">Agent Transfer Matrix</button>
      </div>
      
      <div id="conversations-tab" class="tab-content active">
        <div id="resultsSection" style="display:none;">
          <div class="card">
            <h2 style="margin:0 0 12px;">Conversation Results</h2>
            <div class="stats">
              <div class="stat-card"><div class="stat-number" id="totalConversations">0</div><div class="stat-label">Total Conversations</div></div>
              <div class="stat-card"><div class="stat-number" id="dateRange">-</div><div class="stat-label">Date Range</div></div>
              <div class="stat-card"><div class="stat-number" id="selectedAgent">-</div><div class="stat-label">Selected Agent</div></div>
            </div>
            <div id="results"></div>
          </div>
        </div>
      </div>
      
      <div id="transfers-tab" class="tab-content">
        <div class="card">
          <h2 style="margin:0 0 12px;">Transfer Reporting</h2>
          <div class="filter-controls">
            <select id="transferFilter">
              <option value="all">All Transfers</option>
              <option value="agent-to-agent">Agent ‚Üí Agent (Agent-Initiated Only)</option>
              <option value="queue-to-queue">Queue ‚Üí Queue</option>
            </select>
            <input type="text" id="transferSearch" placeholder="Search by conversation ID">
          </div>
          
          <div id="transferStats" class="transfer-stats"></div>
          <div id="transferTableContainer"></div>
          
          <div id="noTransfersMessage" style="display:none; text-align:center; padding:40px;">
            <div style="font-size:48px;margin-bottom:12px">üîÑ</div>
            <div>No transfers found for the selected criteria.</div>
          </div>
        </div>
      </div>
      
      <div id="queue-transfer-matrix-tab" class="tab-content">
        <div class="card">
          <h2 style="margin:0 0 12px;">Queue Transfer Matrix</h2>
          
          <div class="agent-selector">
            <label for="queueMatrixAgentSelect">Show transfers for:</label>
            <select id="queueMatrixAgentSelect">
              <option value="all">All Agents</option>
            </select>
          </div>
          
          <div id="queueMatrixStats" class="transfer-stats"></div>
          <div id="queueMatrixContainer" class="queue-transfer-matrix"></div>
          
          <div id="noQueueMatrixDataMessage" style="display:none; text-align:center; padding:40px;">
            <div style="font-size:48px;margin-bottom:12px">üìä</div>
            <div>No queue transfer data available for the selected criteria.</div>
          </div>
        </div>
      </div>
      
      <div id="agent-transfer-matrix-tab" class="tab-content">
        <div class="card">
          <h2 style="margin:0 0 12px;">Agent Transfer Matrix</h2>
          
          <div class="agent-selector">
            <label for="agentMatrixAgentSelect">Show transfers for:</label>
            <select id="agentMatrixAgentSelect">
              <option value="all">All Agents</option>
            </select>
          </div>
          
          <div id="agentMatrixStats" class="transfer-stats"></div>
          <div id="agentMatrixContainer" class="queue-transfer-matrix"></div>
          
          <div id="noAgentMatrixDataMessage" style="display:none; text-align:center; padding:40px;">
            <div style="font-size:48px;margin-bottom:12px">üë•</div>
            <div>No agent transfer data available for the selected criteria.</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ===== Config (Ireland) =====
    const CONFIG = {
      clientId: 'fe305808-b368-4547-8af9-325d28d552bb',
      redirectUri: 'https://gmcglynn88.github.io/ConversationExplorer/',
      loginHost: 'https://login.mypurecloud.ie',
      apiHost: 'https://api.mypurecloud.ie'
    };

    // ===== State =====
    const state = { 
      token:null, 
      users:[], 
      queues:{}, 
      conversations:[], 
      selectedAgent:null, 
      convIndex:{},
      allTransfers: [],
      queueTransfers: [],
      agentTransfers: []
    };

    // ===== Utils =====
    const $ = id => document.getElementById(id);
    const setStatus = (msg,err=false)=>{ $('statusMessage').textContent = err?'':(msg||''); $('errorMessage').textContent = err?(msg||''):''; };
    const fmt = d => { if(!d) return 'N/A'; try{return new Date(d).toLocaleString()}catch{return 'N/A'} };
    const fmtDMY = s => { if(!s||s.length<10) return s||''; const [y,m,d]=s.slice(0,10).split('-'); return `${d}-${m}-${y}`; };
    const formatSeconds = ms => { if(!ms) return '0s'; const s=Math.floor(ms/1000), m=Math.floor(s/60), h=Math.floor(m/60); if(h) return `${h}h ${m%60}m ${s%60}s`; if(m) return `${m}m ${s%60}s`; return `${s}s`; };
    const mmss = ms => { const totalSeconds = Math.max(0, Math.floor((+ms||0)/1000)); const minutes = Math.floor(totalSeconds / 60); const seconds = totalSeconds % 60; return String(minutes).padStart(2, '0') + ':' + String(seconds).padStart(2, '0'); };
    const calculateDuration = (a,b)=>{ if(!a||!b) return 0; return new Date(b)-new Date(a); };
    function showMain(){ $('authStatus').style.display='none'; $('mainContent').style.display='block'; }
    function setLoading(v){ $('mainContent').classList.toggle('loading', !!v); }
    function updateProgress(p,cur,total){ $('progressFill').style.width = `${p}%`; $('progressText').textContent = `${Math.round(p)}%`; $('chunkText').textContent = `Chunk ${cur}/${total}`; }
    function showProgress(){ $('progressSection').style.display='block'; $('resultsSection').style.display='none'; }
    function hideProgress(){ $('progressSection').style.display='none'; }

    // ===== Date Range Limiting =====
    function setupDateLimits() {
      const today = new Date().toISOString().split('T')[0];
      $('fromDate').max = today; $('toDate').max = today;
      $('fromDate').addEventListener('change', function() {
        if (this.value > today) this.value = today;
        if ($('toDate').value && this.value > $('toDate').value) $('toDate').value = this.value;
      });
      $('toDate').addEventListener('change', function() {
        if (this.value > today) this.value = today;
        if ($('fromDate').value && this.value < $('fromDate').value) $('fromDate').value = this.value;
      });
    }

    // ===== Tabs =====
    function setupTabs() {
      const tabButtons = document.querySelectorAll('.tab-button');
      const tabContents = document.querySelectorAll('.tab-content');
      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          tabButtons.forEach(btn => btn.classList.remove('active'));
          tabContents.forEach(content => content.classList.remove('active'));
          button.classList.add('active');
          const tabId = button.getAttribute('data-tab') + '-tab';
          document.getElementById(tabId).classList.add('active');
        });
      });
    }

    // ===== Auth =====
    function parseTokenFromHash(){
      const params = new URLSearchParams(location.hash.replace(/^#/, ''));
      return { token: params.get('access_token'), error: params.get('error'), errorDescription: params.get('error_description') };
    }
    function authUrl(){
      return `${CONFIG.loginHost}/oauth/authorize?client_id=${encodeURIComponent(CONFIG.clientId)}&response_type=token&redirect_uri=${encodeURIComponent(CONFIG.redirectUri)}`;
    }
    function initAuth(){
      const {token, error} = parseTokenFromHash();
      if(location.hash) history.replaceState(null,'',location.pathname);

      if(token){
        sessionStorage.removeItem('gc_auto_auth_attempted');
        state.token = token; showMain(); setupDateLimits(); setupTabs(); fetchAllUsers();
        return;
      }

      const attempted = sessionStorage.getItem('gc_auto_auth_attempted');
      if(!attempted && !error){
        sessionStorage.setItem('gc_auto_auth_attempted','1');
        location.assign(authUrl());
        return;
      }

      $('signinBtn').style.display = 'inline-block';
      $('signinBtn').onclick = () => { sessionStorage.setItem('gc_auto_auth_attempted','1'); location.assign(authUrl()); };
      $('authStatus').style.display = 'none';
    }

    // ===== API helper =====
    async function api(path){
      if(!state.token) throw new Error('Not authenticated');
      const res = await fetch(`${CONFIG.apiHost}${path}`, { headers:{Authorization:`Bearer ${state.token}`} });
      if(res.status===401||res.status===403) throw new Error(`Authentication error (${res.status}). Please refresh.`);
      if(!res.ok){ const t = await res.text().catch(()=> ''); throw new Error(`API Error: ${res.status} ${res.statusText}${t?` - ${t.slice(0,200)}`:''}`); }
      return res.json();
    }

    // ===== Users =====
    async function fetchAllUsers(){
      try{
        setStatus('Loading users‚Ä¶'); setLoading(true);
        let all=[], page=1, size=100;
        while(true){
          const data = await api(`/api/v2/users?pageSize=${size}&pageNumber=${page}`);
          const ents = data?.entities||[]; all = all.concat(ents);
          if(!data?.nextUri || ents.length<size) break; page++;
        }
        state.users = all.map(u=>({id:u.id,name:u.name||'',email:u.email||''})).sort((a,b)=>a.name.localeCompare(b.name));
        populateUserSelect(state.users);
        populateMatrixAgentSelects(state.users);
        setStatus(`Loaded ${state.users.length} users`); setLoading(false);
      }catch(e){ setStatus(`Failed to load users: ${e.message}`, true); setLoading(false); $('agentSelect').innerHTML='<option>Failed to load users</option>'; }
    }
    function populateUserSelect(users){
      const sel=$('agentSelect');
      sel.innerHTML = '<option value="">Select an agent‚Ä¶</option>' + users.map(u=>`<option value="${u.id}">${u.name||'(Unnamed)'}</option>`).join('');
      sel.onchange=()=>{ const u = users.find(x=>x.id===sel.value); state.selectedAgent=u||null; if(u){ $('selectedAgentName').textContent=u.name||'(Unnamed)'; $('selectedAgentInfo').style.display='block'; } else { $('selectedAgentInfo').style.display='none'; } };
    }
    function populateMatrixAgentSelects(users) {
      const queueSel = $('queueMatrixAgentSelect');
      const agentSel = $('agentMatrixAgentSelect');
      const options = '<option value="all">All Agents</option>' + 
        users.map(u => `<option value="${u.id}">${u.name || '(Unnamed)'}</option>`).join('');
      queueSel.innerHTML = options;
      agentSel.innerHTML = options;
    }
    $('agentFilter').addEventListener('input', function(){
      const q = this.value.trim().toLowerCase();
      populateUserSelect(q ? state.users.filter(u=>(u.name||'').toLowerCase().includes(q)) : state.users);
    });

    // ===== Chunking =====
    function chunks(start,end,days){
      const out=[]; const s=new Date(start), e=new Date(end); let cur=new Date(s);
      while(cur<=e){ let ce=new Date(cur); ce.setDate(ce.getDate()+days-1); if(ce>e) ce=new Date(e);
        out.push({start:cur.toISOString().slice(0,10), end:ce.toISOString().slice(0,10)}); cur.setDate(cur.getDate()+days);
      } return out;
    }
    function optimalDays(start,end){
      const s=new Date(start), e=new Date(end), total=Math.ceil((e-s)/(1000*60*60*24))+1;
      if(total<=7) return 7; if(total<=30) return 7; if(total<=90) return 5; if(total<=180) return 3; return 2;
    }

    // ===== Queue helpers =====
    function getQueueIdFromParticipant(p){ 
      if(p.queueId) return p.queueId; 
      for(const s of (p.sessions||[])) {
        if(s.queueId) return s.queueId;
        for(const seg of (s.segments||[])) {
          if(seg.queueId) return seg.queueId;
        }
      }
      return null; 
    }

    function getQueueName(id){ 
      if (!id) return null;
      const name = state.queues[id];
      if (name) return name;
      return `Queue ${id.substring(0, 8)}...`;
    }

    async function fetchQueueNames(queueIds) {
      if (!queueIds || queueIds.length === 0) return;
      const queuesToFetch = queueIds.filter(id => !state.queues[id]);
      if (queuesToFetch.length === 0) return;
      const batchSize = 10;
      for (let i = 0; i < queuesToFetch.length; i += batchSize) {
        const batch = queuesToFetch.slice(i, i + batchSize);
        const promises = batch.map(async (queueId) => {
          try {
            const queue = await api(`/api/v2/routing/queues/${queueId}`);
            if (queue && queue.name) {
              state.queues[queueId] = queue.name;
            }
          } catch (e) {
            console.warn(`Could not fetch queue name for ${queueId}:`, e);
            state.queues[queueId] = 'Unknown Queue';
          }
        });
        await Promise.all(promises);
        if (i + batchSize < queuesToFetch.length) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }
    }

    async function warmQueueCache(convs) {
      const queueIds = new Set(); 
      for(const c of convs) {
        for(const p of (c.participants||[])){ 
          const id = getQueueIdFromParticipant(p); 
          if(id) queueIds.add(id); 
        }
        const transferAnalysis = analyzeTransfers(c);
        for(const transfer of transferAnalysis.transfers) {
          if(transfer.fromType === 'Queue' && transfer.fromId) queueIds.add(transfer.fromId);
          if(transfer.toType === 'Queue' && transfer.toId) queueIds.add(transfer.toId);
        }
      }
      await fetchQueueNames([...queueIds]);
    }

    async function refreshMissingQueueNames() {
      const missingQueues = [];
      state.allTransfers.forEach(transfer => {
        if (transfer.fromType === 'Queue' && !state.queues[transfer.fromId]) {
          missingQueues.push(transfer.fromId);
        }
        if (transfer.toType === 'Queue' && !state.queues[transfer.toId]) {
          missingQueues.push(transfer.toId);
        }
      });
      const uniqueMissing = [...new Set(missingQueues)];
      if (uniqueMissing.length > 0) {
        console.log('Refreshing missing queue names:', uniqueMissing);
        await fetchQueueNames(uniqueMissing);
        renderTransferReport();
        renderQueueTransferMatrix();
      }
    }

    // ===== Conversation helpers =====
    function firstSession(c){ for(const p of (c.participants||[])) for(const s of (p.sessions||[])) return s; return null; }
    function getMediaType(c){ return (firstSession(c)?.mediaType)||'Unknown'; }
    function getDirection(c){ return firstSession(c)?.direction || c.originatingDirection || 'Unknown'; }
    function getConversationMediaTypes(c){ const t=new Set(); for(const p of (c.participants||[])) for(const s of (p.sessions||[])) if(s.mediaType) t.add(s.mediaType); return [...t].join(', ')||getMediaType(c); }
    function getANI(c){
      for(const p of (c.participants||[])) for(const s of (p.sessions||[])){
        if((s.mediaType||'').toLowerCase()!=='voice') continue;
        const dir=(s.direction||c.originatingDirection||'').toLowerCase();
        if(dir==='inbound') return s.ani||s.addressFrom||s.otherAddress||s.remote||'Unknown';
      }
      const s=firstSession(c); return s?.ani||s?.addressFrom||s?.otherAddress||s?.remote||'Unknown';
    }
    function getStepStart(p){
      let t=[]; for(const s of (p.sessions||[])){
        if(s.startTime){ const v=+new Date(s.startTime); if(!isNaN(v)) t.push(v); }
        for(const seg of (s.segments||[])){
          if(seg.segmentStart){ const v=+new Date(seg.segmentStart); if(!isNaN(v)) t.push(v); }
          for(const ev of (seg.events||[])) if(ev.eventTime){ const v=+new Date(ev.eventTime); if(!isNaN(v)) t.push(v); }
        }
      }
      return t.length? new Date(Math.min(...t)) : null;
    }
    function getAgentWindow(p){
      let s=[],e=[]; for(const ss of (p.sessions||[])){
        for(const seg of (ss.segments||[])){
          if(seg.segmentStart){ const v=+new Date(seg.segmentStart); if(!isNaN(v)) s.push(v); }
          if(seg.segmentEnd){ const v=+new Date(seg.segmentEnd); if(!isNaN(v)) e.push(v); }
        }
      }
      if(!s.length||!e.length) return {durationMs:0}; return {durationMs: Math.max(...e)-Math.min(...s)};
    }
    function getAlertMsForAgent(p){
      if(!p?.userId) return 0; let total=0; const add=v=>{ if(v==null||isNaN(v))return; const ms=(v>120)?v:v*1000; total+=ms; };
      for(const s of (p.sessions||[])){
        if(Array.isArray(s.metrics)) for(const m of s.metrics) if(m?.name==='tAlert') add(m.value??m.durationMs);
        for(const seg of (s.segments||[])){
          if(Array.isArray(seg.metrics)) for(const m of seg.metrics) if(m?.name==='tAlert') add(m.value??m.durationMs);
          for(const ev of (seg.events||[])) if(Array.isArray(ev.metrics)) for(const m of ev.metrics) if(m?.name==='tAlert') add(m.value??m.durationMs);
        }
      }
      return total;
    }

    function getUserNameById(id){
      const u = state.users.find(u => u.id === id);
      return u ? u.name : `Agent ${id}`;
    }

    // ===== Transfer Analysis (fixed) =====
    function isAgentTransferInitiated(fromParticipant, toParticipant) {
      for (const session of (fromParticipant.sessions || [])) {
        for (const segment of (session.segments || [])) {
          for (const event of (segment.events || [])) {
            if (event.eventType && (
              event.eventType.toLowerCase().includes('transfer') ||
              event.eventType.toLowerCase().includes('redirect') ||
              (event.type && event.type.toLowerCase().includes('transfer'))
            )) {
              return true;
            }
          }
        }
      }
      const fromStart = getStepStart(fromParticipant);
      const toStart = getStepStart(toParticipant);
      if (fromStart && toStart) {
        const timeBetween = toStart.getTime() - fromStart.getTime();
        if (timeBetween < 10000) {
          return false;
        }
      }
      return true;
    }

    function analyzeTransfers(c){
      const transfers = [];
      const timeline = [];
      
      for(const p of (c.participants||[])){
        const queueId = getQueueIdFromParticipant(p);
        const startTime = getStepStart(p);
        const purpose = (p.purpose || '').toLowerCase();
        const name = (p.name || '').toLowerCase();
        
        if (purpose.includes('ivr') || purpose.includes('survey') ||
            name.includes('ivr') || name.includes('survey')) {
          continue;
        }
        
        if(startTime && (queueId || p.userId)) {
          timeline.push({
            time: startTime.getTime(),
            participant: p,
            queueId: queueId,
            userId: p.userId
          });
        }
      }
      
      timeline.sort((a, b) => a.time - b.time);
      
      for(let i = 1; i < timeline.length; i++) {
        const prev = timeline[i-1];
        const curr = timeline[i];
        if(!prev || !curr) continue;
        
        let transferType = '';
        let fromType = '';
        let toType = '';
        let fromId = null;
        let toId = null;
        let fromName = '';
        let toName = '';
        let agentInitiated = true;
        
        if (prev.userId && curr.userId) {
          // Agent ‚Üí Agent
          agentInitiated = isAgentTransferInitiated(prev.participant, curr.participant);
          if (!agentInitiated) continue;
          transferType = 'Agent ‚Üí Agent';
          fromType = 'Agent';
          toType = 'Agent';
          fromId = prev.userId;
          toId = curr.userId;
          fromName = getUserNameById(prev.userId);
          toName = getUserNameById(curr.userId);
        } else if (!prev.userId && prev.queueId && !curr.userId && curr.queueId) {
          // Queue ‚Üí Queue
          transferType = 'Queue ‚Üí Queue';
          fromType = 'Queue';
          toType = 'Queue';
          fromId = prev.queueId;
          toId = curr.queueId;
          fromName = getQueueName(prev.queueId) || `Queue ${prev.queueId}`;
          toName = getQueueName(curr.queueId) || `Queue ${curr.queueId}`;
        } else if (prev.userId && curr.queueId && !curr.userId) {
          // Agent ‚Üí Queue
          transferType = 'Agent ‚Üí Queue';
          fromType = 'Agent';
          toType = 'Queue';
          fromId = prev.userId;
          toId = curr.queueId;
          fromName = getUserNameById(prev.userId);
          toName = getQueueName(curr.queueId) || `Queue ${curr.queueId}`;
        } else if (!prev.userId && prev.queueId && curr.userId) {
          // Queue ‚Üí Agent
          transferType = 'Queue ‚Üí Agent';
          fromType = 'Queue';
          toType = 'Agent';
          fromId = prev.queueId;
          toId = curr.userId;
          fromName = getQueueName(prev.queueId) || `Queue ${prev.queueId}`;
          toName = getUserNameById(curr.userId);
        } else {
          continue;
        }

        if (!fromId || !toId || fromId === toId) continue;
        
        transfers.push({
          step: i,
          fromId,
          toId,
          fromName,
          toName,
          fromType,
          toType,
          time: new Date(curr.time).toISOString(),
          type: transferType,
          conversationId: c.conversationId,
          isAgentInitiated: (fromType === 'Agent' && toType === 'Agent') ? agentInitiated : true
        });
      }
      
      return {totalTransfers: transfers.length, transfers};
    }

    function getParticipantName(p){
      if(p.purpose==='customer') return 'Customer';
      if(p.userId){ const u=state.users.find(x=>x.id===p.userId); return u?u.name:`Agent (${p.userId})`; }
      if(p.purpose==='acd') return 'ACD Queue';
      if(p.purpose==='ivr') return 'IVR System';
      if(p.purpose==='external') return 'External System';
      return p.purpose||'Unknown';
    }
    function getParticipantType(p){
      if(p.purpose==='customer') return 'Customer';
      if(p.userId) return 'Agent';
      if(p.purpose==='acd') return 'Queue';
      if(p.purpose==='ivr') return 'IVR System';
      if(p.purpose==='external') return 'External';
      return p.purpose||'Unknown';
    }
    function badge(purpose,name){
      const cls = {'customer':'badge-customer','user':'badge-agent','acd':'badge-queue','ivr':'badge-ivr','external':'badge-system','queue':'badge-queue'}[purpose]||'badge-system';
      return '<span class="participant-badge ' + cls + '">' + name + '</span>';
    }

    // ===== Transcript helpers (unchanged core logic) =====
    function normaliseRole(v){
      const s=(v||'').toString().toLowerCase();
      if(['internal','agent','user'].includes(s)) return 'internal';
      if(['external','customer','participant','caller','callee'].includes(s)) return 'external';
      return s||'external';
    }
    function labelToScore(v){
      if(v==null) return null;
      if(typeof v==='number') return v;
      const s=v.toString().toUpperCase();
      if(s.includes('POS')) return 0.6;
      if(s.includes('NEG')) return -0.6;
      if(s.includes('NEU')) return 0;
      const n=parseFloat(v); return isNaN(n)?null:n;
    }
    function coerceMs(x){
      const n=Number(x); if(!isNaN(n)) return n;
      const d=+new Date(x); return isNaN(d)?null:d;
    }

    function extractSignals(parsed){
      const out=[]; const buckets=[];
      if(parsed?.analytics) buckets.push(parsed.analytics);
      if(Array.isArray(parsed?.transcripts)){
        for(const tr of parsed.transcripts){ if(tr?.analytics) buckets.push(tr.analytics); }
      }
      for(const a of buckets){
        if(!a) continue;
        if(Array.isArray(a.sentiment)){
          for(const s of a.sentiment){
            out.push({kind:'sentiment',role:normaliseRole(s.participant||s.participantPurpose),startTimeMs:coerceMs(s.startTimeMs),endTimeMs:(s.duration?.milliseconds!=null)?(coerceMs(s.startTimeMs)+Number(s.duration.milliseconds)):coerceMs(s.endTimeMs),value:labelToScore(s.sentiment??s.score??s.value??s.level)});
          }
        }
        if(Array.isArray(a.empathy)){
          for(const e of a.empathy){
            const v=e.empathy??e.score??e.value;
            out.push({kind:'empathy',role:normaliseRole(e.participant||e.participantPurpose),startTimeMs:coerceMs(e.startTimeMs),endTimeMs:(e.duration?.milliseconds!=null)?(coerceMs(e.startTimeMs)+Number(e.duration.milliseconds)):coerceMs(e.endTimeMs),value:(typeof v==='number')?v:labelToScore(v)});
          }
        }
      }
      return out.filter(s=>s.role && s.startTimeMs!=null);
    }

    function processPhrases(parsed){
      let phrases=[];
      if(Array.isArray(parsed?.transcripts)){
        parsed.transcripts.forEach(tr=>{ if(Array.isArray(tr.phrases)) phrases=phrases.concat(tr.phrases); });
      }
      if(Array.isArray(parsed?.phrases)) phrases=phrases.concat(parsed.phrases);
      return phrases.map(ph=>{
        const start=coerceMs(ph.startTimeMs??ph.startTime??ph.offsetMs??ph.offset);
        const end=coerceMs(ph.endTimeMs??ph.endTime??(start!=null?start+3000:null));
        const role=normaliseRole(ph.participantPurpose??ph.participant??ph.role);
        const text=ph.decoratedText??ph.text??ph.transcript??'';
        const conf=(typeof ph.confidence==='number')?ph.confidence
                 :(typeof ph.confidenceScore==='number')?ph.confidenceScore
                 :(typeof ph.asrConfidence==='number')?ph.asrConfidence:null;
        const directSent=ph.sentimentScore??ph.sentiment??ph.analytics?.sentiment??null;
        const directEmp =ph.empathyScore??ph.empathy??ph.analytics?.empathy??null;
        return {
          participantPurpose: role||'external',
          decoratedText: text,
          startTimeMs: start ?? 0,
          endTimeMs: end ?? ((start ?? 0)+3000),
          sentimentDirect: labelToScore(directSent),
          empathyDirect: (typeof directEmp==='number')?directEmp:labelToScore(directEmp),
          confidence: (typeof conf==='number'?conf:null),
          participantId: ph.participantId,
          userIds: ph.userIds||[],
          externalContactIds: ph.externalContactIds||[]
        };
      }).filter(p=>p.decoratedText && p.startTimeMs!=null).sort((a,b)=>a.startTimeMs-b.startTimeMs);
    }

    const SENTIMENT_POS = 0.15;
    const SENTIMENT_NEG = -0.15;
    const EMPATHY_GOOD  = 0.20;

    function sentimentToLabel(v){
      if (v == null || isNaN(v)) return {label:'-', css:'sentiment-neutral'};
      if (v > SENTIMENT_POS)     return {label:'Positive', css:'sentiment-positive'};
      if (v < SENTIMENT_NEG)     return {label:'Negative', css:'sentiment-negative'};
      return {label:'Neutral', css:'sentiment-neutral'};
    }
    function empathyToLabel(v){
      if (v == null || isNaN(v)) return {label:'-', css:''};
      return (v > EMPATHY_GOOD)
        ? {label:'Empathetic', css:'empathy-positive'}
        : {label:'Unhelpful',  css:'empathy-negative'};
    }

    async function getTranscriptForConversation(conversationId){
      const statusEl = document.querySelector('#transcript-status-' + conversationId);
      const container = document.querySelector('#transcript-' + conversationId);
      const btn = document.querySelector('#btn-transcript-' + conversationId);
      if(!state.token){ alert('Not authenticated'); return; }
      const conv = state.convIndex[conversationId]; if(!conv){ statusEl.textContent='Conversation not found in state.'; return; }
      const commId = findCommunicationsIdFromDetails(conv);
      if(!commId){ statusEl.textContent='No sessionId found to use as communicationsId.'; return; }
      try{
        btn.disabled=true; statusEl.textContent='Requesting transcript URL‚Ä¶';
        const urlRes = await fetch(CONFIG.apiHost + '/api/v2/speechandtextanalytics/conversations/' + conversationId + '/communications/' + commId + '/transcripturl', {headers:{Authorization:'Bearer ' + state.token}});
        if(!urlRes.ok){ const t=await urlRes.text().catch(()=> ''); throw new Error('Transcript URL error: ' + urlRes.status + ' ' + urlRes.statusText + (t?' - ' + t.slice(0,200):'')); }
        const {url:presigned} = await urlRes.json(); if(!presigned) throw new Error('No URL in transcript response.');
        statusEl.textContent='Downloading transcript‚Ä¶';
        const raw = await fetch(presigned); if(!raw.ok) throw new Error('Transcript download failed: ' + raw.status + ' ' + raw.statusText);
        const text = await raw.text(); let parsed=null; try{ parsed=JSON.parse(text);}catch{}
        statusEl.textContent='Rendering transcript‚Ä¶';
        renderTranscript(container, parsed, text, conv);
        statusEl.textContent='Transcript loaded.';
      }catch(e){
        console.error(e); statusEl.innerHTML='‚ö†Ô∏è ' + e.message + '<span class="muted"> ‚Äî If this is a CORS issue, try opening the raw URL in a new tab.</span>';
      }finally{ btn.disabled=false; }
    }
    window.getTranscriptForConversation = getTranscriptForConversation;

    const SIGNAL_ANCHOR_TOL_MS = 1500;

    function renderTranscript(container, parsed, rawText, conversation){
      const escapeHtml = s => (s||'').toString().replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[c]));

      const phrases = processPhrases(parsed);
      const signals = extractSignals(parsed);
      if (!phrases.length){
        container.innerHTML = '<div class="muted">No transcript phrases found.</div>' +
          '<details><summary>Show Raw Data for Debugging</summary><pre>' + escapeHtml(typeof rawText==='string'?rawText:JSON.stringify(parsed,null,2)) + '</pre></details>';
        return;
      }

      const enriched = phrases.map(p=>({
        ...p,
        sentiment: (p.sentimentDirect!=null)?Number(p.sentimentDirect):null,
        empathy:   (p.empathyDirect!=null)?Number(p.empathyDirect):null
      }));

      const sentiments = signals.filter(s=>s.kind==='sentiment' && s.role==='external');
      const empathies  = signals.filter(s=>s.kind==='empathy'  && s.role==='internal');

      function assignNearest(signalsArr, role, field){
        for(const s of signalsArr){
          let bestIdx=-1, bestDelta=Infinity;
          for(let i=0;i<enriched.length;i++){
            const p=enriched[i];
            if(p.participantPurpose!==role) continue;
            const d=Math.abs((p.startTimeMs??0) - (s.startTimeMs??0));
            if(d<=SIGNAL_ANCHOR_TOL_MS && d<bestDelta){ bestDelta=d; bestIdx=i; }
          }
          if(bestIdx>=0){
            if(enriched[bestIdx][field]==null) enriched[bestIdx][field]=s.value;
          }
        }
      }

      assignNearest(sentiments,'external','sentiment');
      assignNearest(empathies,'internal','empathy');

      const nameMap = mapParticipantNames(conversation);
      const { internal, external } = participantsByType(conversation);

      function sentimentCell(p){
        if(p.participantPurpose!=='external' || p.sentiment==null) return '-';
        const {label, css} = sentimentToLabel(Number(p.sentiment));
        return `<span class="${css}">${label}</span>`;
      }
      function empathyCell(p){
        if(p.participantPurpose!=='internal' || p.empathy==null) return '-';
        const {label, css} = empathyToLabel(Number(p.empathy));
        return `<span class="${css}">${label}</span>`;
      }
      function confidenceCell(p){
        const v = (p.confidence!=null) ? Number(p.confidence) : null;
        if(v==null || isNaN(v)) return '-';
        const fixed=v.toFixed(3);
        if(v>=0.8) return `<span class="confidence-high">${fixed}</span>`;
        if(v>=0.6) return `<span class="confidence-medium">${fixed}</span>`;
        return `<span class="confidence-low">${fixed}</span>`;
      }
      function displayName(p){
        if(p.participantPurpose==='internal'){
          if(p.userIds && p.userIds.length){
            const id=p.userIds[0];
            return nameMap[id] || (state.users.find(u=>u.id===id)?.name) || internal[0] || 'Agent';
          }
          return internal[0] || 'Agent';
        }
        return external[0] || 'Customer';
      }

      const convStart = new Date(conversation.conversationStart).getTime();

      let html = '<div class="transcript-summary">';
      html += '<div class="t-summary-grid">';
      html += '<div class="t-kv"><span class="k">Interaction Type:</span><span>' + (getConversationMediaTypes(conversation) || 'Voice') + '</span></div>';
      html += '<div class="t-kv"><span class="k">Conversation Start:</span><span>' + fmt(conversation.conversationStart) + '</span></div>';
      html += '<div class="t-kv"><span class="k">Conversation End:</span><span>' + fmt(conversation.conversationEnd) + '</span></div>';
      html += '<div class="t-kv"><span class="k">Interaction ID:</span><span class="mono">' + conversation.conversationId + '</span></div>';
      html += '<div class="t-kv"><span class="k">Duration:</span><span>' + formatSeconds(calculateDuration(conversation.conversationStart, conversation.conversationEnd)) + '</span></div>';
      html += '<div class="t-kv"><span class="k">Direction:</span><span>' + (getDirection(conversation) || 'Unknown') + '</span></div>';
      html += '</div></div>';

      html += '<table class="transcript-table"><thead><tr>';
      html += '<th>Time (MM:SS)</th>';
      html += '<th>Participant Type</th>';
      html += '<th>Participant</th>';
      html += '<th>Participant Text</th>';
      html += '<th>Sentiment</th>';
      html += '<th>Empathy</th>';
      html += '<th>Confidence</th>';
      html += '</tr></thead><tbody>';

      enriched.forEach(p=>{
        const absolute = p.startTimeMs>1e12;
        const rel = absolute ? (p.startTimeMs - convStart) : p.startTimeMs;
        const timeFormatted = mmss(Math.max(0, rel));
        const participantType = p.participantPurpose==='internal' ? 'Internal' : 'External';
        let row = '<tr>';
        row += '<td class="mono" style="font-weight:bold;">'+timeFormatted+'</td>';
        row += '<td>'+participantType+'</td>';
        row += '<td>'+escapeHtml(displayName(p))+'</td>';
        row += '<td>'+escapeHtml(p.decoratedText)+'</td>';
        row += '<td>'+sentimentCell(p)+'</td>';
        row += '<td>'+empathyCell(p)+'</td>';
        row += '<td>'+confidenceCell(p)+'</td>';
        row += '</tr>';
        html += row;
      });

      html += '</tbody></table>';

      container.innerHTML = html;
    }

    function mapParticipantNames(conv){
      const map={};
      for(const p of (conv.participants||[])){
        if(p.userId){ const u=state.users.find(x=>x.id===p.userId); map[p.participantId||p.userId] = u?u.name:`Agent (${p.userId})`; }
        else if(p.purpose==='customer'){ map[p.participantId||'customer']='Customer'; }
        else if(p.purpose==='acd'){ const qid=getQueueIdFromParticipant(p); map[p.participantId||qid||'acd']=qid?(getQueueName(qid)||'Queue'):'Queue'; }
      } return map;
    }
    function participantsByType(conv){
      const internal=new Set(), external=new Set();
      for(const p of (conv.participants||[])){
        if(p.userId){ const u=state.users.find(x=>x.id===p.userId); internal.add(u?u.name:`Agent (${p.userId})`); }
        else if(p.purpose==='customer'){ external.add(p.participantName||'Customer'); }
      } return {internal:[...internal], external:[...external]};
    }
    function findCommunicationsIdFromDetails(conv){
      for(const p of (conv.participants||[])) for(const s of (p.sessions||[])) if((s.mediaType||'').toLowerCase()==='voice' && s.sessionId) return s.sessionId;
      for(const p of (conv.participants||[])) for(const s of (p.sessions||[])) if(s.sessionId) return s.sessionId;
      for(const p of (conv.participants||[])) for(const s of (p.sessions||[])) if(s.communicationId) return s.communicationId;
      for(const p of (conv.participants||[])) for(const s of (p.sessions||[])) if(s.id) return s.id;
      return null;
    }

    // ===== Fetch conversations =====
    async function fetchConversations(){
      try{
        if(!state.selectedAgent){ setStatus('Please select an agent first', true); return; }
        const from=$('fromDate').value, to=$('toDate').value||from;
        if(!from){ setStatus('Please select a start date', true); return; }
        const today = new Date().toISOString().split('T')[0];
        if(from > today || to > today) { setStatus('Date range cannot be in the future', true); return; }

        setStatus('Fetching conversations‚Ä¶'); setLoading(true); $('resultsSection').style.display='none';

        const auto=$('autoChunk').checked;
        const days = auto? optimalDays(from,to) : (new Date(to)-new Date(from) >= 0 ? (Math.ceil((new Date(to)-new Date(from))/(1000*60*60*24))+1) : 1);
        const dateChunks = auto? chunks(from,to,days) : [{start:from,end:to}];

        $('chunkInfo').innerHTML = auto
          ? 'Large range: <strong>' + fmtDMY(from) + ' to ' + fmtDMY(to) + '</strong><br>Auto-splitting into <strong>' + dateChunks.length + ' chunks</strong> of ' + days + ' days.'
          : 'Processing range: <strong>' + fmtDMY(from) + ' to ' + fmtDMY(to) + '</strong>';

        showProgress();
        state.conversations=[]; state.convIndex={};
        state.allTransfers = [];
        state.queueTransfers = [];
        state.agentTransfers = [];

        for(let i=0;i<dateChunks.length;i++){
          const ch=dateChunks[i]; updateProgress((i/dateChunks.length)*100, i+1, dateChunks.length);
          setStatus('Fetching chunk ' + (i+1) + '/' + dateChunks.length + ': ' + ch.start + ' ‚Üí ' + ch.end);
          try{
            const body = { interval: ch.start + 'T00:00:00/' + ch.end + 'T23:59:59', order:'asc', orderBy:'conversationStart', segmentFilters:[{type:'and',predicates:[{type:'dimension',dimension:'userId',operator:'matches',value: state.selectedAgent.id }]}] };
            const res = await fetch(CONFIG.apiHost + '/api/v2/analytics/conversations/details/query', { method:'POST', headers:{Authorization:'Bearer ' + state.token,'Content-Type':'application/json'}, body:JSON.stringify(body) });
            if(!res.ok){ const t=await res.text().catch(()=> ''); throw new Error('Details error: ' + res.status + ' ' + res.statusText + (t?' - ' + t.slice(0,200):'')); }
            const data = await res.json(); const convs = data.conversations||[];
            for(const c of convs) state.convIndex[c.conversationId]=c;
            state.conversations = state.conversations.concat(convs);
            
            for(const conv of convs) {
              const transferAnalysis = analyzeTransfers(conv);
              if(transferAnalysis.transfers.length > 0) {
                state.allTransfers = state.allTransfers.concat(
                  transferAnalysis.transfers.map(t => ({
                    ...t,
                    conversationId: conv.conversationId,
                    conversationStart: conv.conversationStart
                  }))
                );
                const queueTransfers = transferAnalysis.transfers.filter(t => 
                  t.fromType === 'Queue' && t.toType === 'Queue'
                );
                if (queueTransfers.length > 0) {
                  state.queueTransfers = state.queueTransfers.concat(
                    queueTransfers.map(t => ({
                      ...t,
                      conversationId: conv.conversationId,
                      conversationStart: conv.conversationStart
                    }))
                  );
                }
                const agentTransfers = transferAnalysis.transfers.filter(t => 
                  t.type === 'Agent ‚Üí Agent' && t.isAgentInitiated
                );
                if (agentTransfers.length > 0) {
                  state.agentTransfers = state.agentTransfers.concat(
                    agentTransfers.map(t => ({
                      ...t,
                      conversationId: conv.conversationId,
                      conversationStart: conv.conversationStart
                    }))
                  );
                }
              }
            }
          }catch(e){ console.error(e); setStatus('Warning: failed chunk ' + (i+1) + ', continuing‚Ä¶', true); }
          if(i<dateChunks.length-1) await new Promise(r=>setTimeout(r,400));
        }

        await warmQueueCache(state.conversations);
        await refreshMissingQueueNames();

        updateProgress(100, dateChunks.length, dateChunks.length);
        renderResults(state.conversations, from, to);
        renderTransferReport();
        renderQueueTransferMatrix();
        renderAgentTransferMatrix();
        setStatus('Found ' + state.conversations.length + ' conversations for the selected period');
        setLoading(false); hideProgress();
      }catch(e){ setStatus('Error fetching conversations: ' + e.message, true); setLoading(false); hideProgress(); }
    }

    function renderResults(conversations, from, to){
      const results=$('results');
      $('dateRange').textContent = fmtDMY(from) + ' to ' + fmtDMY(to||from);
      $('selectedAgent').textContent = state.selectedAgent?.name||'-';
      $('totalConversations').textContent = conversations.length;

      if(!conversations.length){
        results.innerHTML = '<div class="muted" style="text-align:center;padding:40px"><div style="font-size:48px;margin-bottom:12px">üì≠</div><div>No conversations found for ' + (state.selectedAgent?.name||'the selected agent') + '.</div></div>';
        $('resultsSection').style.display='block'; return;
      }

      results.innerHTML = conversations.map(function(conv){
        const participants = conv.participants ? conv.participants.length : 0;
        const media = getConversationMediaTypes(conv);
        const dir = getDirection(conv);
        return '<details><summary><strong>' + conv.conversationId + '</strong> - ' + fmt(conv.conversationStart) + '<span class="muted" style="margin-left:8px;font-size:.9em">(' + participants + ' participants) ‚Ä¢ Media: ' + media + ' ‚Ä¢ Dir: ' + dir + '</span></summary>' + renderConversationDetails(conv) + '</details>';
      }).join('');

      $('resultsSection').style.display='block';
    }

    function renderConversationDetails(conv){
      const mediaType = getMediaType(conv);
      const direction = getDirection(conv);
      const ani = getANI(conv);
      const totalDur = calculateDuration(conv.conversationStart, conv.conversationEnd);
      const transfers = analyzeTransfers(conv);

      let html = '<div class="conversation-header">';
      html += '<div class="info-grid">';
      html += '<div class="info-item"><span class="info-label">Media Type:</span><span class="info-value">' + mediaType + '</span></div>';
      html += '<div class="info-item"><span class="info-label">Customer Number:</span><span class="info-value">' + ani + '</span></div>';
      html += '<div class="info-item"><span class="info-label">Interaction Direction:</span><span class="info-value">' + direction + '</span></div>';
      html += '<div class="info-item"><span class="info-label">Conversation Start:</span><span class="info-value">' + fmt(conv.conversationStart) + '</span></div>';
      html += '<div class="info-item"><span class="info-label">Conversation End:</span><span class="info-value">' + fmt(conv.conversationEnd) + '</span></div>';
      html += '<div class="info-item"><span class="info-label">Duration:</span><span class="info-value">' + formatSeconds(totalDur) + '</span></div>';
      html += '<div class="info-item"><span class="info-label">Transfers (Agent/Queue):</span><span class="info-value"><span class="transfer-count">' + transfers.totalTransfers + '</span></span></div>';
      html += '</div>';

      html += '<div class="transcript-actions" style="display:flex;gap:8px;align-items:center;margin-top:8px">';
      html += '<button id="btn-transcript-' + conv.conversationId + '" onclick="getTranscriptForConversation(\'' + conv.conversationId + '\')">Get Transcript</button>';
      html += '<span id="transcript-status-' + conv.conversationId + '" class="muted"></span>';
      html += '</div>';
      html += '<div id="transcript-' + conv.conversationId + '" style="margin-top:10px;"></div>';
      html += '</div>';

      html += '<h3 style="margin:14px 0 6px;">Customer Journey Timeline</h3>';
      html += '<div class="journey-timeline">';
      html += renderJourneyTimeline(conv, transfers);
      html += '</div>';

      html += '<details><summary>Raw Conversation Data</summary><pre>' + JSON.stringify(conv, null, 2) + '</pre></details>';
      
      return html;
    }

    function renderJourneyTimeline(conv, transferInfo){
      if(!conv.participants || !conv.participants.length) return '<p class="muted">No participant data available</p>';
      const sorted = [...conv.participants].map(function(p){return {p:p,start:getStepStart(p)};})
        .sort(function(a,b){return (a.start?.getTime()??Infinity)-(b.start?.getTime()??Infinity);})
        .map(function(x){return x.p;});

      return sorted.map(function(p,idx){
        const purpose = p.purpose||'unknown';
        const start = getStepStart(p);
        const nextStart = idx<sorted.length-1 ? getStepStart(sorted[idx+1]) : null;
        const queueId = getQueueIdFromParticipant(p);
        const queueName = queueId ? (getQueueName(queueId)||queueId) : null;
        const name = purpose==='acd' ? (queueName?'Queue: ' + queueName:'ACD Queue') : getParticipantName(p);

        let durMs = 0;
        if(p.userId) durMs = getAgentWindow(p).durationMs||0;
        else if(start && nextStart) durMs = Math.max(0, nextStart - start);

        const alertMs = p.userId ? getAlertMsForAgent(p) : null;
        const alertTime = p.userId ? (Math.floor((alertMs||0)/1000) + 's') : 'N/A';

        const transfer = transferInfo.transfers.find(function(t){return t.step===idx;});

        let stepHtml = '<div class="journey-step">';
        stepHtml += '<div class="step-header">Step ' + (idx+1) + ': ' + badge(purpose, name) + (transfer?'<span style="color:#dc2626;margin-left:8px">üîÑ TRANSFERRED</span>':'') + '</div>';
        stepHtml += '<div class="step-details">';
        if(transfer){
          stepHtml += '<div class="transfer-info"><strong>Transfer:</strong> ' + transfer.type + '<br>From: ' + transfer.fromName + ' ‚Üí ' + transfer.toName + '<br>Time: ' + fmt(transfer.time) + '</div>';
        }
        stepHtml += '<div class="info-grid">';
        stepHtml += '<div class="info-item"><span class="info-label">Participant Type:</span><span class="info-value">' + getParticipantType(p) + '</span></div>';
        stepHtml += '<div class="info-item"><span class="info-label">Start Time:</span><span class="info-value">' + fmt(start) + '</span></div>';
        if(queueName) stepHtml += '<div class="info-item"><span class="info-label">Queue:</span><span class="info-value">' + queueName + '</span></div>';
        stepHtml += '<div class="info-item"><span class="info-label">Duration:</span><span class="info-value">' + formatSeconds(durMs) + '</span></div>';
        stepHtml += '<div class="info-item"><span class="info-label">Alert Time:</span><span class="info-value">' + alertTime + '</span></div>';
        stepHtml += '<div class="info-item"><span class="info-label">Purpose:</span><span class="info-value">' + purpose + '</span></div>';
        stepHtml += '<div class="info-item"><span class="info-label">Sessions:</span><span class="info-value">' + ((p.sessions&&p.sessions.length)||1) + '</span></div>';
        stepHtml += '</div></div></div>';
        return stepHtml;
      }).join('');
    }

    // ===== Transfer Reporting =====
    function renderTransferReport() {
      const statsContainer = $('transferStats');
      const tableContainer = $('transferTableContainer');
      const noTransfersMessage = $('noTransfersMessage');
      
      if (state.allTransfers.length === 0) {
        statsContainer.innerHTML = '';
        tableContainer.innerHTML = '';
        noTransfersMessage.style.display = 'block';
        return;
      }
      
      noTransfersMessage.style.display = 'none';
      
      const totalTransfers = state.allTransfers.length;
      const agentToAgent = state.allTransfers.filter(t => t.type === 'Agent ‚Üí Agent' && t.isAgentInitiated).length;
      const queueToQueue = state.allTransfers.filter(t => t.fromType === 'Queue' && t.toType === 'Queue').length;
      
      statsContainer.innerHTML = `
        <div class="transfer-stat-card">
          <div class="transfer-stat-number">${totalTransfers}</div>
          <div class="transfer-stat-label">Total Transfers</div>
        </div>
        <div class="transfer-stat-card">
          <div class="transfer-stat-number">${agentToAgent}</div>
          <div class="transfer-stat-label">Agent ‚Üí Agent<br><small>(Agent-Initiated Only)</small></div>
        </div>
        <div class="transfer-stat-card">
          <div class="transfer-stat-number">${queueToQueue}</div>
          <div class="transfer-stat-label">Queue ‚Üí Queue</div>
        </div>
      `;
      
      const filterType = $('transferFilter').value;
      const searchTerm = $('transferSearch').value.toLowerCase();
      
      let filteredTransfers = state.allTransfers;
      
      if (filterType !== 'all') {
        filteredTransfers = filteredTransfers.filter(t => {
          if (filterType === 'agent-to-agent') return t.type === 'Agent ‚Üí Agent' && t.isAgentInitiated;
          if (filterType === 'queue-to-queue') return t.fromType === 'Queue' && t.toType === 'Queue';
          return true;
        });
      }
      
      if (searchTerm) {
        filteredTransfers = filteredTransfers.filter(t => 
          t.conversationId.toLowerCase().includes(searchTerm)
        );
      }
      
      const transfersByConversation = {};
      filteredTransfers.forEach(transfer => {
        if (!transfersByConversation[transfer.conversationId]) {
          transfersByConversation[transfer.conversationId] = [];
        }
        transfersByConversation[transfer.conversationId].push(transfer);
      });
      
      if (Object.keys(transfersByConversation).length === 0) {
        tableContainer.innerHTML = '<div style="text-align:center;padding:20px">No transfers match the selected filters</div>';
        return;
      }
      
      let html = '';
      Object.entries(transfersByConversation).forEach(([conversationId, transfers]) => {
        const sortedTransfers = transfers.sort((a, b) => new Date(a.time) - new Date(b.time));
        
        html += `
          <div class="conversation-transfer-group">
            <div class="conversation-transfer-header" onclick="this.nextElementSibling.classList.toggle('open')">
              <span>${conversationId} <span class="conversation-transfer-count">${transfers.length} transfer${transfers.length > 1 ? 's' : ''}</span></span>
              <span>${fmt(sortedTransfers[0].conversationStart)}</span>
            </div>
            <div class="conversation-transfer-details">
        `;
        
        sortedTransfers.forEach((transfer, index) => {
          html += `
            <div class="transfer-leg">
              <div class="transfer-leg-number">${index + 1}</div>
              <div class="transfer-leg-content">
                <strong>${transfer.fromName}</strong>
                <span class="transfer-leg-arrow">‚Üí</span>
                <strong>${transfer.toName}</strong>
                <span style="margin-left: 12px; color: var(--text-light);">${transfer.type} ‚Ä¢ ${fmt(transfer.time)}</span>
              </div>
            </div>
          `;
        });
        
        html += `
            </div>
          </div>
        `;
      });
      
      tableContainer.innerHTML = html;
    }
    
    // ===== Queue Transfer Matrix =====
    function renderQueueTransferMatrix() {
      const statsContainer = $('queueMatrixStats');
      const matrixContainer = $('queueMatrixContainer');
      const noMatrixDataMessage = $('noQueueMatrixDataMessage');
      const selectedAgentId = $('queueMatrixAgentSelect').value;
      
      let transfersToShow = state.queueTransfers;
      
      if (selectedAgentId !== 'all') {
        const agentConversations = state.conversations.filter(conv => 
          conv.participants && conv.participants.some(p => p.userId === selectedAgentId)
        );
        const agentConversationIds = new Set(agentConversations.map(c => c.conversationId));
        transfersToShow = transfersToShow.filter(t => agentConversationIds.has(t.conversationId));
      }
      
      if (transfersToShow.length === 0) {
        statsContainer.innerHTML = '';
        matrixContainer.innerHTML = '';
        noMatrixDataMessage.style.display = 'block';
        return;
      }
      
      noMatrixDataMessage.style.display = 'none';
      
      const totalQueueTransfers = transfersToShow.length;
      const uniqueFromQueues = [...new Set(transfersToShow.map(t => t.fromId))].length;
      const uniqueToQueues = [...new Set(transfersToShow.map(t => t.toId))].length;
      
      statsContainer.innerHTML = `
        <div class="transfer-stat-card">
          <div class="transfer-stat-number">${totalQueueTransfers}</div>
          <div class="transfer-stat-label">Queue Transfers</div>
        </div>
        <div class="transfer-stat-card">
          <div class="transfer-stat-number">${uniqueFromQueues}</div>
          <div class="transfer-stat-label">Source Queues</div>
        </div>
        <div class="transfer-stat-card">
          <div class="transfer-stat-number">${uniqueToQueues}</div>
          <div class="transfer-stat-label">Target Queues</div>
        </div>
      `;
      
      const fromQueues = [...new Set(transfersToShow.map(t => t.fromId))];
      const toQueues = [...new Set(transfersToShow.map(t => t.toId))];
      const allQueueIds = [...new Set([...fromQueues, ...toQueues])];
      
      const matrix = {};
      allQueueIds.forEach(fromQueueId => {
        matrix[fromQueueId] = {};
        allQueueIds.forEach(toQueueId => {
          matrix[fromQueueId][toQueueId] = 0;
        });
      });
      
      transfersToShow.forEach(transfer => {
        if (matrix[transfer.fromId] && matrix[transfer.fromId][transfer.toId] !== undefined) {
          matrix[transfer.fromId][transfer.toId]++;
        }
      });
      
      const sortedQueueIds = allQueueIds.sort((a, b) => {
        const nameA = (getQueueName(a) || '').toLowerCase();
        const nameB = (getQueueName(b) || '').toLowerCase();
        return nameA.localeCompare(nameB);
      });
      
      let matrixHtml = '<table class="matrix-table">';
      matrixHtml += '<thead><tr>';
      matrixHtml += '<th class="from-header">FROM / TO</th>';
      sortedQueueIds.forEach(queueId => {
        const queueName = getQueueName(queueId);
        matrixHtml += `<th class="to-header">${queueName}</th>`;
      });
      matrixHtml += '</tr></thead>';
      
      matrixHtml += '<tbody>';
      sortedQueueIds.forEach(fromQueueId => {
        const fromQueueName = getQueueName(fromQueueId);
        matrixHtml += `<tr><td class="from-label">${fromQueueName}</td>`;
        
        sortedQueueIds.forEach(toQueueId => {
          const count = matrix[fromQueueId][toQueueId];
          let cellClass = '';
          if (count > 0) {
            if (count >= 10) cellClass = 'matrix-high';
            else if (count >= 5) cellClass = 'matrix-medium';
            else cellClass = 'matrix-low';
          }
          matrixHtml += `<td class="${cellClass}"><span class="matrix-count">${count}</span></td>`;
        });
        
        matrixHtml += '</tr>';
      });
      matrixHtml += '</tbody></table>';
      
      matrixContainer.innerHTML = matrixHtml;
    }
    
    // ===== Agent Transfer Matrix =====
    function renderAgentTransferMatrix() {
      const statsContainer = $('agentMatrixStats');
      const matrixContainer = $('agentMatrixContainer');
      const noMatrixDataMessage = $('noAgentMatrixDataMessage');
      const selectedAgentId = $('agentMatrixAgentSelect').value;
      
      let transfersToShow = state.agentTransfers;
      
      if (selectedAgentId !== 'all') {
        const agentConversations = state.conversations.filter(conv => 
          conv.participants && conv.participants.some(p => p.userId === selectedAgentId)
        );
        const agentConversationIds = new Set(agentConversations.map(c => c.conversationId));
        transfersToShow = transfersToShow.filter(t => agentConversationIds.has(t.conversationId));
      }
      
      if (transfersToShow.length === 0) {
        statsContainer.innerHTML = '';
        matrixContainer.innerHTML = '';
        noMatrixDataMessage.style.display = 'block';
        return;
      }
      
      noMatrixDataMessage.style.display = 'none';
      
      const totalAgentTransfers = transfersToShow.length;
      const uniqueFromAgents = [...new Set(transfersToShow.map(t => t.fromId))].length;
      const uniqueToAgents = [...new Set(transfersToShow.map(t => t.toId))].length;
      
      statsContainer.innerHTML = `
        <div class="transfer-stat-card">
          <div class="transfer-stat-number">${totalAgentTransfers}</div>
          <div class="transfer-stat-label">Agent Transfers<br><small>(Agent-Initiated Only)</small></div>
        </div>
        <div class="transfer-stat-card">
          <div class="transfer-stat-number">${uniqueFromAgents}</div>
          <div class="transfer-stat-label">Source Agents</div>
        </div>
        <div class="transfer-stat-card">
          <div class="transfer-stat-number">${uniqueToAgents}</div>
          <div class="transfer-stat-label">Target Agents</div>
        </div>
      `;
      
      const fromAgents = [...new Set(transfersToShow.map(t => t.fromId))];
      const toAgents = [...new Set(transfersToShow.map(t => t.toId))];
      const allAgents = [...new Set([...fromAgents, ...toAgents])];
      
      const matrix = {};
      allAgents.forEach(fromAgent => {
        matrix[fromAgent] = {};
        allAgents.forEach(toAgent => {
          matrix[fromAgent][toAgent] = 0;
        });
      });
      
      transfersToShow.forEach(transfer => {
        if (matrix[transfer.fromId] && matrix[transfer.fromId][transfer.toId] !== undefined) {
          matrix[transfer.fromId][transfer.toId]++;
        }
      });
      
      let matrixHtml = '<table class="matrix-table">';
      matrixHtml += '<thead><tr>';
      matrixHtml += '<th class="from-header">FROM / TO</th>';
      allAgents.forEach(agentId => {
        const agent = state.users.find(u => u.id === agentId);
        const agentName = agent ? agent.name : `Agent ${agentId}`;
        matrixHtml += `<th class="to-header">${agentName}</th>`;
      });
      matrixHtml += '</tr></thead>';
      
      matrixHtml += '<tbody>';
      allAgents.forEach(fromAgentId => {
        const fromAgent = state.users.find(u => u.id === fromAgentId);
        const fromAgentName = fromAgent ? fromAgent.name : `Agent ${fromAgentId}`;
        matrixHtml += `<tr><td class="from-label">${fromAgentName}</td>`;
        
        allAgents.forEach(toAgentId => {
          const count = matrix[fromAgentId][toAgentId];
          let cellClass = '';
          if (count > 0) {
            if (count >= 10) cellClass = 'matrix-high';
            else if (count >= 5) cellClass = 'matrix-medium';
            else cellClass = 'matrix-low';
          }
          
          matrixHtml += `<td class="${cellClass}"><span class="matrix-count">${count}</span></td>`;
        });
        
        matrixHtml += '</tr>';
      });
      matrixHtml += '</tbody></table>';
      
      matrixContainer.innerHTML = matrixHtml;
    }
    
    function setupTransferFilters() {
      $('transferFilter').addEventListener('change', renderTransferReport);
      $('transferSearch').addEventListener('input', renderTransferReport);
      $('queueMatrixAgentSelect').addEventListener('change', renderQueueTransferMatrix);
      $('agentMatrixAgentSelect').addEventListener('change', renderAgentTransferMatrix);
    }

    // ===== Events & Init =====
    $('fetchBtn').addEventListener('click', fetchConversations);
    (function init(){
      const today=new Date(); const weekAgo=new Date(); weekAgo.setDate(today.getDate()-7);
      $('fromDate').value = weekAgo.toISOString().slice(0,10);
      $('toDate').value = today.toISOString().slice(0,10);
      initAuth();
      setupTransferFilters();
    })();
  </script>
</body>
</html>
