<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Genesys Conversation Explorer</title>
  <style>
    :root{
      --primary-color:#63AB8F; --secondary-color:#4A8C7D; --border-color:#DEE2E6;
      --light-bg:#F8F9FA; --card-bg:#FFFFFF; --text-color:#2C3E50; --text-light:#6C757D;
      --pill:#e9f6f0;
    }
    body{font-family:'Segoe UI',Arial,sans-serif;margin:20px;padding:20px;max-width:1200px;background:var(--light-bg);color:var(--text-color)}
    #logo-container{text-align:center;margin-bottom:20px} #logo{width:300px}
    h1{margin:0 0 16px}
    .card{background:var(--card-bg);border:1px solid var(--border-color);border-radius:12px;padding:24px;margin-top:16px;box-shadow:0 1px 3px rgba(0,0,0,.1)}
    label{display:block;font-weight:600;margin-bottom:6px}
    select,input,button{padding:10px;border:1px solid var(--border-color);border-radius:6px;background:var(--card-bg);font-size:14px}
    button{background:var(--primary-color);color:#fff;font-weight:600;cursor:pointer;transition:background .2s}
    button:hover{background:var(--secondary-color)} button:disabled{background:var(--text-light);cursor:not-allowed}
    .controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:20px 24px;align-items:start}
    .inline{display:grid;grid-template-columns:1fr auto 1fr;gap:16px;align-items:center} .inline span{color:var(--text-light)}
    .full-width-btn{width:100%;padding:14px 18px;font-size:16px;margin-top:12px}
    .muted{color:var(--text-light)} .mono{font-family:ui-monospace,Consolas,Menlo,monospace}
    .user-info,.conversation-header,.transcript-summary{background:transparent;border:2px solid var(--primary-color);border-radius:10px;padding:16px;margin:12px 0}
    details{background:var(--light-bg);border:1px solid var(--border-color);border-radius:8px;padding:16px;margin:12px 0}
    details>summary{cursor:pointer;font-weight:600}
    pre{background:#1f2937;color:#f3f4f6;padding:16px;border-radius:6px;overflow:auto;font-size:12px}
    .stats{display:flex;gap:16px;margin:16px 0}
    .stat-card{flex:1;border:1px solid var(--border-color);border-radius:8px;padding:16px;text-align:center;background:var(--card-bg)}
    .stat-number{font-size:22px;color:var(--primary-color);font-weight:700}
    .journey-timeline{margin:20px 0 8px;padding-left:20px;border-left:3px solid var(--primary-color)}
    .journey-step{margin-bottom:18px;position:relative}
    .journey-step:before{content:'';position:absolute;left:-26px;top:0;width:16px;height:16px;border-radius:50%;background:var(--primary-color)}
    .step-header{font-weight:700;color:var(--secondary-color);margin-bottom:8px}
    .step-details{background:var(--card-bg);border:1px solid var(--border-color);border-radius:6px;padding:12px}
    .info-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:12px}
    .info-item{display:flex;justify-content:space-between;border-bottom:1px solid var(--border-color);padding:6px 0}
    .info-label{font-weight:600;min-width:150px}
    .participant-badge{display:inline-block;padding:4px 8px;border-radius:4px;font-size:12px;font-weight:600;margin:2px;border:1px solid var(--border-color);background:#fff}
    .badge-customer{border-color:#a7e3c6;color:#1f7255}
    .badge-agent{background:#dbeafe;color:#1e40af}
    .badge-queue{background:#fde7ff;color:#7c3aed}
    .transfer-info{background:#fff7ed;border:1px solid var(--border-color);border-radius:6px;padding:8px;margin:8px 0}
    .transfer-count{background:#fee2e2;color:#b91c1c;padding:2px 8px;border-radius:6px;font-weight:700}
    .progress-bar{width:100%;height:8px;background:var(--border-color);border-radius:4px;overflow:hidden;margin:10px 0}
    .progress-fill{height:100%;background:var(--primary-color);transition:width .3s}
    .t-summary-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:10px 16px}
    .t-kv{display:flex;gap:10px;justify-content:space-between}.t-kv .k{font-weight:700}
    .pill{display:inline-block;background:var(--pill);border:1px solid var(--border-color);border-radius:999px;padding:2px 8px;font-size:12px;margin-right:6px}
    .transcript-table{width:100%;border-collapse:collapse;margin-top:10px}
    .transcript-table th,.transcript-table td{border-bottom:1px solid var(--border-color);padding:8px 10px;vertical-align:top}
    .transcript-table th{background:var(--primary-color);color:#fff;text-align:left}
    .sentiment-positive{color:#16a34a;font-weight:700}
    .sentiment-negative{color:#dc2626;font-weight:700}
    .sentiment-neutral{color:#f59e0b;font-weight:700}
    .empathy-positive{color:#16a34a;font-weight:700}
    .confidence-high{color:#16a34a;font-weight:700}
    .confidence-medium{color:#f59e0b;font-weight:700}
    .confidence-low{color:#dc2626;font-weight:700}
    .loading{opacity:.6;pointer-events:none}
    .future-date{color:#ccc;cursor:not-allowed}
  </style>
</head>
<body>
  <div id="logo-container">
    <img id="logo" src="https://raw.githubusercontent.com/gmcglynn88/ExternalWorkCreation/main/Consultinglogo.png" alt="Company Logo">
  </div>
  <h1>Conversation Explorer</h1>
  <button id="signinBtn" style="display:none;margin-bottom:12px;">Sign in to Genesys Cloud</button>

  <div id="authStatus" class="card" style="display:none;">
    <div style="text-align:center;padding:20px;">
      <div style="font-size:18px;color:var(--secondary-color);margin-bottom:8px;">üîê Authenticating‚Ä¶</div>
      <div class="muted">Connecting to Genesys Cloud</div>
    </div>
  </div>

  <div id="mainContent" style="display:none;">
    <div class="card">
      <h2 style="margin:0 0 12px;">Select Agent & Date Range</h2>
      <div class="controls">
        <div>
          <label for="agentSelect">Select Agent</label>
          <select id="agentSelect"><option>Loading users‚Ä¶</option></select>
          <input id="agentFilter" type="text" placeholder="Filter users by name" style="margin-top:8px"/>
          <div class="user-info" id="selectedAgentInfo" style="display:none;">
            <strong>Selected Agent:</strong> <span id="selectedAgentName">None</span>
          </div>
        </div>
        <div>
          <label>Date Range</label>
          <div class="inline">
            <input id="fromDate" type="date"/>
            <span>to</span>
            <input id="toDate" type="date"/>
          </div>
          <label style="display:flex;align-items:center;gap:8px;margin-top:8px;">
            <input id="autoChunk" type="checkbox" checked/> Auto-split large date ranges (recommended)
          </label>
        </div>
      </div>
      <button id="fetchBtn" class="full-width-btn">Fetch Conversations</button>
    </div>

    <div id="statusMessage" class="muted" style="margin-top:10px;"></div>
    <div id="errorMessage" style="color:#dc2626;margin-top:6px;"></div>

    <div id="progressSection" style="display:none;">
      <div class="card">
        <h3 style="margin:0 0 8px;">Fetching Conversations</h3>
        <div class="muted" id="chunkInfo">Processing date range in smaller chunks‚Ä¶</div>
        <div class="progress-bar"><div class="progress-fill" id="progressFill" style="width:0%"></div></div>
        <div style="display:flex;justify-content:space-between;font-size:14px" class="muted">
          <span id="progressText">0%</span><span id="chunkText">Chunk 0/0</span>
        </div>
      </div>
    </div>

    <div id="resultsSection" style="display:none;">
      <div class="card">
        <h2 style="margin:0 0 12px;">Conversation Results</h2>
        <div class="stats">
          <div class="stat-card"><div class="stat-number" id="totalConversations">0</div><div class="stat-label">Total Conversations</div></div>
          <div class="stat-card"><div class="stat-number" id="dateRange">-</div><div class="stat-label">Date Range</div></div>
          <div class="stat-card"><div class="stat-number" id="selectedAgent">-</div><div class="stat-label">Selected Agent</div></div>
        </div>
        <div id="results"></div>
      </div>
    </div>
  </div>

  <script>
    // ===== Config (Ireland) =====
    const CONFIG = {
      clientId: 'd4529142-7340-4cd8-a9f9-f3a4d25670df',
      redirectUri: 'https://gmcglynn88.github.io/ConversationExplorer/',
      loginHost: 'https://login.mypurecloud.ie',
      apiHost: 'https://api.mypurecloud.ie'
    };

    // ===== State =====
    const state = { token:null, users:[], queues:{}, conversations:[], selectedAgent:null, convIndex:{} };

    // ===== Utils =====
    const $ = id => document.getElementById(id);
    const setStatus = (msg,err=false)=>{ $('statusMessage').textContent = err?'':(msg||''); $('errorMessage').textContent = err?(msg||''):''; };
    const fmt = d => { if(!d) return 'N/A'; try{return new Date(d).toLocaleString()}catch{return 'N/A'} };
    const fmtDMY = s => { if(!s||s.length<10) return s||''; const [y,m,d]=s.slice(0,10).split('-'); return `${d}-${m}-${y}`; };
    const formatSeconds = ms => { if(!ms) return '0s'; const s=Math.floor(ms/1000), m=Math.floor(s/60), h=Math.floor(m/60); if(h) return `${h}h ${m%60}m ${s%60}s`; if(m) return `${m}m ${s%60}s`; return `${s}s`; };
    const mmss = ms => { 
      const totalSeconds = Math.max(0, Math.floor((+ms||0)/1000));
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      return String(minutes).padStart(2, '0') + ':' + String(seconds).padStart(2, '0');
    };
    const calculateDuration = (a,b)=>{ if(!a||!b) return 0; return new Date(b)-new Date(a); };

    function showAuthStatus(){ $('authStatus').style.display='block'; $('mainContent').style.display='none'; }
    function showMain(){ $('authStatus').style.display='none'; $('mainContent').style.display='block'; }
    function setLoading(v){ $('mainContent').classList.toggle('loading', !!v); }
    function updateProgress(p,cur,total){ $('progressFill').style.width = `${p}%`; $('progressText').textContent = `${Math.round(p)}%`; $('chunkText').textContent = `Chunk ${cur}/${total}`; }
    function showProgress(){ $('progressSection').style.display='block'; $('resultsSection').style.display='none'; }
    function hideProgress(){ $('progressSection').style.display='none'; }

    // ===== Date Range Limiting =====
    function setupDateLimits() {
      const today = new Date().toISOString().split('T')[0];
      
      // Set max attribute to today for both date inputs
      $('fromDate').max = today;
      $('toDate').max = today;
      
      // Add event listeners to prevent future dates
      $('fromDate').addEventListener('change', function() {
        if (this.value > today) {
          this.value = today;
        }
        // Ensure toDate is not before fromDate
        if ($('toDate').value && this.value > $('toDate').value) {
          $('toDate').value = this.value;
        }
      });
      
      $('toDate').addEventListener('change', function() {
        if (this.value > today) {
          this.value = today;
        }
        // Ensure fromDate is not after toDate
        if ($('fromDate').value && this.value < $('fromDate').value) {
          $('fromDate').value = this.value;
        }
      });
    }

    // ===== Auth (Implicit) =====
    function parseTokenFromHash(){
      const params = new URLSearchParams(location.hash.replace(/^#/, ''));
      return { token: params.get('access_token'), error: params.get('error'), errorDescription: params.get('error_description') };
    }
    function authUrl(){
      return `${CONFIG.loginHost}/oauth/authorize?client_id=${encodeURIComponent(CONFIG.clientId)}&response_type=token&redirect_uri=${encodeURIComponent(CONFIG.redirectUri)}`;
    }
    
    function initAuth(){
      console.log('Initializing auth...');
      
      const {token,error,errorDescription} = parseTokenFromHash();
      console.log('Token present:', !!token);
      console.log('Error:', error);
      
      if(location.hash) {
        console.log('Clearing hash from URL');
        history.replaceState(null,'',location.pathname);
      }
      
      if(token){
        console.log('Authentication successful');
        state.token = token;
        showMain();
        setupDateLimits(); // Initialize date limits
        fetchAllUsers();
      } else {
        console.log('No token found, showing signin option');
        $('signinBtn').style.display = 'inline-block';
        $('signinBtn').onclick = () => {
          console.log('Initiating OAuth flow');
          location.assign(authUrl());
        };
        $('authStatus').style.display = 'none';
      }
    }

    // ===== API helper =====
    async function api(path){
      if(!state.token) throw new Error('Not authenticated');
      const res = await fetch(`${CONFIG.apiHost}${path}`, { headers:{Authorization:`Bearer ${state.token}`} });
      if(res.status===401||res.status===403) throw new Error(`Authentication error (${res.status}). Please refresh.`);
      if(!res.ok){ const t = await res.text().catch(()=> ''); throw new Error(`API Error: ${res.status} ${res.statusText}${t?` - ${t.slice(0,200)}`:''}`); }
      return res.json();
    }

    // ===== Users =====
    async function fetchAllUsers(){
      try{
        setStatus('Loading users‚Ä¶'); setLoading(true);
        let all=[], page=1, size=100;
        while(true){
          const data = await api(`/api/v2/users?pageSize=${size}&pageNumber=${page}`);
          const ents = data?.entities||[]; all = all.concat(ents);
          if(!data?.nextUri || ents.length<size) break; page++;
        }
        state.users = all.map(u=>({id:u.id,name:u.name||'',email:u.email||''})).sort((a,b)=>a.name.localeCompare(b.name));
        populateUserSelect(state.users);
        setStatus(`Loaded ${state.users.length} users`); setLoading(false);
      }catch(e){ setStatus(`Failed to load users: ${e.message}`, true); setLoading(false); $('agentSelect').innerHTML='<option>Failed to load users</option>'; }
    }
    function populateUserSelect(users){
      const sel=$('agentSelect');
      sel.innerHTML = '<option value="">Select an agent‚Ä¶</option>' + users.map(u=>`<option value="${u.id}">${u.name||'(Unnamed)'}</option>`).join('');
      sel.onchange=()=>{
        const u = users.find(x=>x.id===sel.value);
        state.selectedAgent=u||null;
        if(u){ $('selectedAgentName').textContent=u.name||'(Unnamed)'; $('selectedAgentInfo').style.display='block'; }
        else{ $('selectedAgentInfo').style.display='none'; }
      };
    }
    $('agentFilter').addEventListener('input', function(){
      const q = this.value.trim().toLowerCase();
      populateUserSelect(q ? state.users.filter(u=>(u.name||'').toLowerCase().includes(q)) : state.users);
    });

    // ===== Chunking =====
    function chunks(start,end,days){
      const out=[]; const s=new Date(start), e=new Date(end); let cur=new Date(s);
      while(cur<=e){ let ce=new Date(cur); ce.setDate(ce.getDate()+days-1); if(ce>e) ce=new Date(e);
        out.push({start:cur.toISOString().slice(0,10), end:ce.toISOString().slice(0,10)}); cur.setDate(cur.getDate()+days);
      } return out;
    }
    function optimalDays(start,end){
      const s=new Date(start), e=new Date(end), total=Math.ceil((e-s)/(1000*60*60*24))+1;
      if(total<=7) return 7; if(total<=30) return 7; if(total<=90) return 5; if(total<=180) return 3; return 2;
    }

    // ===== Queue helpers =====
    function getQueueIdFromParticipant(p){ if(p.queueId) return p.queueId; for(const s of (p.sessions||[])) if(s.queueId) return s.queueId; return null; }
    function getQueueName(id){ return state.queues[id]||null; }
    async function fetchQueueName(id){ if(!id||state.queues[id]) return; try{ const q=await api(`/api/v2/routing/queues/${id}`); state.queues[id]=q?.name||id; }catch{ state.queues[id]=id; } }
    async function warmQueueCache(convs){
      const set=new Set(); for(const c of convs) for(const p of (c.participants||[])){ const id=getQueueIdFromParticipant(p); if(id) set.add(id); }
      await Promise.all([...set].filter(id=>!state.queues[id]).map(fetchQueueName));
    }

    // ===== Conversation helpers =====
    function firstSession(c){ for(const p of (c.participants||[])) for(const s of (p.sessions||[])) return s; return null; }
    function getMediaType(c){ return (firstSession(c)?.mediaType)||'Unknown'; }
    function getDirection(c){ return firstSession(c)?.direction || c.originatingDirection || 'Unknown'; }
    function getConversationMediaTypes(c){ const t=new Set(); for(const p of (c.participants||[])) for(const s of (p.sessions||[])) if(s.mediaType) t.add(s.mediaType); return [...t].join(', ')||getMediaType(c); }
    function getANI(c){
      for(const p of (c.participants||[])) for(const s of (p.sessions||[])){
        if((s.mediaType||'').toLowerCase()!=='voice') continue;
        const dir=(s.direction||c.originatingDirection||'').toLowerCase();
        if(dir==='inbound') return s.ani||s.addressFrom||s.otherAddress||s.remote||'Unknown';
      }
      const s=firstSession(c); return s?.ani||s?.addressFrom||s?.otherAddress||s?.remote||'Unknown';
    }
    function getStepStart(p){
      let t=[]; for(const s of (p.sessions||[])){
        if(s.startTime){ const v=+new Date(s.startTime); if(!isNaN(v)) t.push(v); }
        for(const seg of (s.segments||[])){
          if(seg.segmentStart){ const v=+new Date(seg.segmentStart); if(!isNaN(v)) t.push(v); }
          for(const ev of (seg.events||[])) if(ev.eventTime){ const v=+new Date(ev.eventTime); if(!isNaN(v)) t.push(v); }
        }
      }
      return t.length? new Date(Math.min(...t)) : null;
    }
    function getAgentWindow(p){
      let s=[],e=[]; for(const ss of (p.sessions||[])){
        for(const seg of (ss.segments||[])){
          if(seg.segmentStart){ const v=+new Date(seg.segmentStart); if(!isNaN(v)) s.push(v); }
          if(seg.segmentEnd){ const v=+new Date(seg.segmentEnd); if(!isNaN(v)) e.push(v); }
        }
      }
      if(!s.length||!e.length) return {durationMs:0}; return {durationMs: Math.max(...e)-Math.min(...s)};
    }
    function getAlertMsForAgent(p){
      if(!p?.userId) return 0; let total=0; const add=v=>{ if(v==null||isNaN(v))return; const ms=(v>120)?v:v*1000; total+=ms; };
      for(const s of (p.sessions||[])){
        if(Array.isArray(s.metrics)) for(const m of s.metrics) if(m?.name==='tAlert') add(m.value??m.durationMs);
        for(const seg of (s.segments||[])){
          if(Array.isArray(seg.metrics)) for(const m of seg.metrics) if(m?.name==='tAlert') add(m.value??m.durationMs);
          for(const ev of (seg.events||[])) if(Array.isArray(ev.metrics)) for(const m of ev.metrics) if(m?.name==='tAlert') add(m.value??m.durationMs);
        }
      }
      return total;
    }
    function buildLegs(c){
      const legs=[]; for(const p of (c.participants||[])){
        const when=getStepStart(p)?.getTime()??Infinity; legs.push({when,purpose:p.purpose,userId:p.userId||null,queueId:getQueueIdFromParticipant(p)||null});
      }
      legs.sort((a,b)=>a.when-b.when); return legs.filter(l=>Number.isFinite(l.when));
    }
    function analyzeTransfers(c){
      const legs=buildLegs(c), transfers=[]; let count=0;
      for(let i=1;i<legs.length;i++){ const prev=legs[i-1], cur=legs[i];
        const a2a = prev.userId && cur.userId && prev.userId!==cur.userId;
        const a2q = prev.userId && cur.queueId && !cur.userId;
        if(a2a||a2q){ count++; transfers.push({step:i,from: prev.userId?'Agent':(prev.queueId?'Queue':(prev.purpose||'Unknown')), to: cur.userId?'Agent':(cur.queueId?'Queue':(cur.purpose||'Unknown')), time:new Date(cur.when).toISOString(), type:a2a?'Agent ‚Üí Agent':'Agent ‚Üí Queue'}); }
      }
      return {totalTransfers:count, transfers};
    }
    function getParticipantName(p){
      if(p.purpose==='customer') return 'Customer';
      if(p.userId){ const u=state.users.find(x=>x.id===p.userId); return u?u.name:`Agent (${p.userId})`; }
      if(p.purpose==='acd') return 'ACD Queue';
      if(p.purpose==='ivr') return 'IVR System';
      if(p.purpose==='external') return 'External System';
      return p.purpose||'Unknown';
    }
    function getParticipantType(p){
      if(p.purpose==='customer') return 'Customer';
      if(p.userId) return 'Agent';
      if(p.purpose==='acd') return 'Queue';
      if(p.purpose==='ivr') return 'IVR System';
      if(p.purpose==='external') return 'External';
      return p.purpose||'Unknown';
    }
    function badge(purpose,name){
      const cls = {'customer':'badge-customer','user':'badge-agent','acd':'badge-queue','ivr':'badge-ivr','external':'badge-system','queue':'badge-queue'}[purpose]||'badge-system';
      return '<span class="participant-badge ' + cls + '">' + name + '</span>';
    }

    // ===== Transcript helpers =====
    function mapParticipantNames(conv){
      const map={};
      for(const p of (conv.participants||[])){
        if(p.userId){ const u=state.users.find(x=>x.id===p.userId); map[p.participantId||p.userId] = u?u.name:`Agent (${p.userId})`; }
        else if(p.purpose==='customer'){ map[p.participantId||'customer']='Customer'; }
        else if(p.purpose==='acd'){ const qid=getQueueIdFromParticipant(p); map[p.participantId||qid||'acd']=qid?(getQueueName(qid)||'Queue'):'Queue'; }
      } return map;
    }
    function participantsByType(conv){
      const internal=new Set(), external=new Set();
      for(const p of (conv.participants||[])){
        if(p.userId){ const u=state.users.find(x=>x.id===p.userId); internal.add(u?u.name:`Agent (${p.userId})`); }
        else if(p.purpose==='customer'){ external.add(p.participantName||'Customer'); }
      } return {internal:[...internal], external:[...external]};
    }
    function findCommunicationsIdFromDetails(conv){
      for(const p of (conv.participants||[])) for(const s of (p.sessions||[])) if((s.mediaType||'').toLowerCase()==='voice' && s.sessionId) return s.sessionId;
      for(const p of (conv.participants||[])) for(const s of (p.sessions||[])) if(s.sessionId) return s.sessionId;
      for(const p of (conv.participants||[])) for(const s of (p.sessions||[])) if(s.communicationId) return s.communicationId;
      for(const p of (conv.participants||[])) for(const s of (p.sessions||[])) if(s.id) return s.id;
      return null;
    }

    async function getTranscriptForConversation(conversationId){
      const statusEl = document.querySelector('#transcript-status-' + conversationId);
      const container = document.querySelector('#transcript-' + conversationId);
      const btn = document.querySelector('#btn-transcript-' + conversationId);
      if(!state.token){ alert('Not authenticated'); return; }
      const conv = state.convIndex[conversationId]; if(!conv){ statusEl.textContent='Conversation not found in state.'; return; }

      const commId = findCommunicationsIdFromDetails(conv);
      if(!commId){ statusEl.textContent='No sessionId found to use as communicationsId.'; return; }

      try{
        btn.disabled=true; statusEl.textContent='Requesting transcript URL‚Ä¶';
        const urlRes = await fetch(CONFIG.apiHost + '/api/v2/speechandtextanalytics/conversations/' + conversationId + '/communications/' + commId + '/transcripturl', {headers:{Authorization:'Bearer ' + state.token}});
        if(!urlRes.ok){ const t=await urlRes.text().catch(()=> ''); throw new Error('Transcript URL error: ' + urlRes.status + ' ' + res.statusText + (t?' - ' + t.slice(0,200):'')); }
        const {url:presigned} = await urlRes.json(); if(!presigned) throw new Error('No URL in transcript response.');
        statusEl.textContent='Downloading transcript‚Ä¶';
        const raw = await fetch(presigned); if(!raw.ok) throw new Error('Transcript download failed: ' + raw.status + ' ' + raw.statusText);
        const text = await raw.text(); let parsed=null; try{ parsed=JSON.parse(text);}catch{}
        statusEl.textContent='Rendering transcript‚Ä¶';
        renderTranscript(container, parsed, text, conv);
        statusEl.textContent='Transcript loaded.';
      }catch(e){
        console.error(e); statusEl.innerHTML='‚ö†Ô∏è ' + e.message + '<br><span class="muted">If this is a CORS issue, try opening the raw URL in a new tab.</span>';
      }finally{ btn.disabled=false; }
    }
    window.getTranscriptForConversation = getTranscriptForConversation;

    // === FIXED transcript renderer with analytics sentiment and empathy ===
    function renderTranscript(container, parsed, rawText, conversation){
      const escapeHtml = s => (s||'').replace(/[&<>"']/g, function(c){return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[c]});
      
      console.log('Transcript data structure:', parsed);
      
      // Extract all phrases from all transcripts
      let allPhrases = [];
      
      if (parsed && Array.isArray(parsed.transcripts)) {
        parsed.transcripts.forEach(transcript => {
          if (transcript.phrases && Array.isArray(transcript.phrases)) {
            allPhrases = allPhrases.concat(transcript.phrases);
          }
        });
      }
      
      console.log('All phrases found:', allPhrases);

      // Extract sentiment and empathy from analytics
      let sentimentAnalytics = [];
      let empathyAnalytics = [];
      
      if (parsed && parsed.analytics) {
        if (parsed.analytics.sentiment && Array.isArray(parsed.analytics.sentiment)) {
          sentimentAnalytics = parsed.analytics.sentiment;
        }
        if (parsed.analytics.empathy && Array.isArray(parsed.analytics.empathy)) {
          empathyAnalytics = parsed.analytics.empathy;
        }
      }
      
      console.log('Sentiment analytics:', sentimentAnalytics);
      console.log('Empathy analytics:', empathyAnalytics);

      if (!allPhrases || allPhrases.length === 0) {
        container.innerHTML = '<div class="muted">No transcript phrases found.</div>' +
          '<details><summary>Show Raw Data for Debugging</summary><pre>' + escapeHtml(JSON.stringify(parsed, null, 2)) + '</pre></details>';
        return;
      }

      // Process phrases to extract the data we need
      const processedPhrases = allPhrases
        .map(phrase => {
          // Find matching sentiment for this phrase
          let sentimentScore = null;
          const matchingSentiment = sentimentAnalytics.find(s => 
            Math.abs(s.startTimeMs - phrase.startTimeMs) < 1000 && // Match by timestamp
            s.participant === phrase.participantPurpose // Match by participant type
          );
          if (matchingSentiment) {
            sentimentScore = matchingSentiment.sentiment;
          }
          
          // Find matching empathy for this phrase
          let empathyScore = null;
          const matchingEmpathy = empathyAnalytics.find(e => 
            Math.abs(e.startTimeMs - phrase.startTimeMs) < 1000 && // Match by timestamp
            e.participant === phrase.participantPurpose // Match by participant type
          );
          if (matchingEmpathy) {
            empathyScore = matchingEmpathy.empathy;
          }
          
          // Extract confidence score
          let confidenceScore = phrase.confidence;
          
          return {
            participantPurpose: phrase.participantPurpose || 'external',
            decoratedText: phrase.decoratedText || phrase.text || '',
            startTimeMs: phrase.startTimeMs || 0,
            sentiment: sentimentScore,
            empathy: empathyScore,
            confidence: confidenceScore,
            participantId: phrase.participantId,
            userIds: phrase.userIds || [],
            externalContactIds: phrase.externalContactIds || []
          };
        })
        .filter(p => p.decoratedText && p.decoratedText.trim()) // Remove empty phrases
        .sort((a, b) => a.startTimeMs - b.startTimeMs); // Sort by timestamp

      console.log('Processed phrases with scores:', processedPhrases);

      const nameMap = mapParticipantNames(conversation);
      const { internal, external } = participantsByType(conversation);

      // Function to format sentiment - ONLY for external participants (customers)
      function formatSentiment(phrase) {
        // Only show sentiment for external participants (customers)
        if (phrase.participantPurpose !== 'external') {
          return '-';
        }
        
        const score = phrase.sentiment;
        if (score === null || score === undefined || isNaN(score)) return '-';
        
        const val = Number(score);
        const fixed = val.toFixed(3);
        if (val > 0.1) return '<span class="sentiment-positive">' + fixed + '</span>';
        if (val < -0.1) return '<span class="sentiment-negative">' + fixed + '</span>';
        return '<span class="sentiment-neutral">' + fixed + '</span>';
      }

      // Function to format empathy - ONLY for internal participants (agents)
      function formatEmpathy(phrase) {
        // Only show empathy for internal participants (agents)
        if (phrase.participantPurpose !== 'internal') {
          return '-';
        }
        
        const score = phrase.empathy;
        if (score === null || score === undefined || isNaN(score)) return '-';
        
        const val = Number(score);
        const fixed = val.toFixed(3);
        if (val > 0.1) return '<span class="empathy-positive">' + fixed + '</span>';
        return fixed;
      }

      // Function to format confidence - for ALL participants
      function formatConfidence(phrase) {
        const score = phrase.confidence;
        if (score === null || score === undefined || isNaN(score)) return '-';
        
        const val = Number(score);
        const fixed = val.toFixed(3);
        if (val >= 0.8) return '<span class="confidence-high">' + fixed + '</span>';
        if (val >= 0.6) return '<span class="confidence-medium">' + fixed + '</span>';
        return '<span class="confidence-low">' + fixed + '</span>';
      }

      // Function to get participant display name
      function getParticipantDisplay(phrase) {
        const purpose = phrase.participantPurpose;
        
        if (purpose === 'internal') {
          // For internal participants, try to find the agent name from userIds
          if (phrase.userIds && phrase.userIds.length > 0) {
            const userId = phrase.userIds[0];
            if (nameMap[userId]) {
              return nameMap[userId];
            }
            // Try to find user in state.users
            const user = state.users.find(u => u.id === userId);
            if (user) {
              return user.name;
            }
          }
          return internal[0] || 'Agent';
        } else {
          // For external participants
          return external[0] || 'Customer';
        }
      }

      // Calculate relative timestamps (from conversation start)
      const conversationStartTime = new Date(conversation.conversationStart).getTime();
      
      // Build the transcript HTML with ALL columns
      let html = '<div class="transcript-summary">';
      html += '<div class="t-summary-grid">';
      html += '<div class="t-kv"><span class="k">Interaction Type:</span><span>' + (getConversationMediaTypes(conversation) || 'Voice') + '</span></div>';
      html += '<div class="t-kv"><span class="k">Interaction ID:</span><span class="mono">' + conversation.conversationId + '</span></div>';
      html += '<div class="t-kv"><span class="k">Conversation Start:</span><span>' + fmt(conversation.conversationStart) + '</span></div>';
      html += '<div class="t-kv"><span class="k">Conversation End:</span><span>' + fmt(conversation.conversationEnd) + '</span></div>';
      html += '<div class="t-kv"><span class="k">Duration:</span><span>' + formatSeconds(calculateDuration(conversation.conversationStart, conversation.conversationEnd)) + '</span></div>';
      html += '<div class="t-kv"><span class="k">Direction:</span><span>' + (getDirection(conversation) || 'Unknown') + '</span></div>';
      html += '<div class="t-kv"><span class="k">Internal Participant(s):</span><span>' + (internal.length ? internal.map(function(n){ return '<span class="pill">' + escapeHtml(n) + '</span>'; }).join(' ') : '-') + '</span></div>';
      html += '<div class="t-kv"><span class="k">External Participant(s):</span><span>' + (external.length ? external.map(function(n){ return '<span class="pill">' + escapeHtml(n) + '</span>'; }).join(' ') : '-') + '</span></div>';
      html += '</div></div>';

      // Table with all columns: Time, Participant Type, Participant, Text, Sentiment, Empathy, Confidence
      html += '<table class="transcript-table"><thead><tr>';
      html += '<th>Time (MM:SS)</th>';
      html += '<th>Participant Type</th>';
      html += '<th>Participant</th>';
      html += '<th>Participant Text</th>';
      html += '<th>Sentiment</th>';
      html += '<th>Empathy</th>';
      html += '<th>Confidence</th>';
      html += '</tr></thead><tbody>';

      if (processedPhrases.length === 0) {
        html += '<tr><td colspan="7" class="muted" style="text-align:center;">No transcript content found</td></tr>';
      } else {
        processedPhrases.forEach(function(phrase) {
          // Calculate relative time from conversation start
          const relativeTimeMs = phrase.startTimeMs - conversationStartTime;
          const timeFormatted = mmss(relativeTimeMs);
          const participantType = phrase.participantPurpose === 'internal' ? 'Internal' : 'External';
          const participantName = getParticipantDisplay(phrase);
          
          html += '<tr>';
          html += '<td class="mono" style="font-weight:bold;">' + timeFormatted + '</td>';
          html += '<td>' + participantType + '</td>';
          html += '<td>' + escapeHtml(participantName) + '</td>';
          html += '<td>' + escapeHtml(phrase.decoratedText) + '</td>';
          html += '<td>' + formatSentiment(phrase) + '</td>';
          html += '<td>' + formatEmpathy(phrase) + '</td>';
          html += '<td>' + formatConfidence(phrase) + '</td>';
          html += '</tr>';
        });
      }

      html += '</tbody></table>';
      
      // Add debug information
      const customerPhrases = processedPhrases.filter(p => p.participantPurpose === 'external');
      const agentPhrases = processedPhrases.filter(p => p.participantPurpose === 'internal');
      
      const customerPhrasesWithSentiment = customerPhrases.filter(p => p.sentiment !== null && p.sentiment !== undefined);
      const agentPhrasesWithEmpathy = agentPhrases.filter(p => p.empathy !== null && p.empathy !== undefined);
      const phrasesWithConfidence = processedPhrases.filter(p => p.confidence !== null && p.confidence !== undefined);
      
      html += '<div class="muted" style="margin-top:16px;padding:12px;background:#f8f9fa;border-radius:6px;">';
      html += '<strong>Analytics Summary:</strong><br>';
      html += 'Total phrases: ' + processedPhrases.length + '<br>';
      html += 'Customer phrases: ' + customerPhrases.length + ' (with sentiment: ' + customerPhrasesWithSentiment.length + ')<br>';
      html += 'Agent phrases: ' + agentPhrases.length + ' (with empathy: ' + agentPhrasesWithEmpathy.length + ')<br>';
      html += 'Phrases with confidence: ' + phrasesWithConfidence.length + '<br>';
      html += 'Sentiment analytics found: ' + sentimentAnalytics.length + '<br>';
      html += 'Empathy analytics found: ' + empathyAnalytics.length + '<br>';
      html += '</div>';
      
      container.innerHTML = html;
    }

    // ===== Fetch conversations =====
    async function fetchConversations(){
      try{
        if(!state.selectedAgent){ setStatus('Please select an agent first', true); return; }
        const from=$('fromDate').value, to=$('toDate').value||from;
        if(!from){ setStatus('Please select a start date', true); return; }

        // Validate dates are not in future
        const today = new Date().toISOString().split('T')[0];
        if(from > today || to > today) {
          setStatus('Date range cannot be in the future', true);
          return;
        }

        setStatus('Fetching conversations‚Ä¶'); setLoading(true); $('resultsSection').style.display='none';

        const auto=$('autoChunk').checked;
        const days = auto? optimalDays(from,to) : (new Date(to)-new Date(from) >= 0 ? (Math.ceil((new Date(to)-new Date(from))/(1000*60*60*24))+1) : 1);
        const dateChunks = auto? chunks(from,to,days) : [{start:from,end:to}];

        $('chunkInfo').innerHTML = auto
          ? 'Large range: <strong>' + fmtDMY(from) + ' to ' + fmtDMY(to) + '</strong><br>Auto-splitting into <strong>' + dateChunks.length + ' chunks</strong> of ' + days + ' days.'
          : 'Processing range: <strong>' + fmtDMY(from) + ' to ' + fmtDMY(to) + '</strong>';

        showProgress();
        state.conversations=[]; state.convIndex={};

        for(let i=0;i<dateChunks.length;i++){
          const ch=dateChunks[i]; updateProgress((i/dateChunks.length)*100, i+1, dateChunks.length);
          setStatus('Fetching chunk ' + (i+1) + '/' + dateChunks.length + ': ' + ch.start + ' ‚Üí ' + ch.end);
          try{
            const body = {
              interval: ch.start + 'T00:00:00/' + ch.end + 'T23:59:59',
              order:'asc', orderBy:'conversationStart',
              segmentFilters:[{type:'and',predicates:[{type:'dimension',dimension:'userId',operator:'matches',value: state.selectedAgent.id }]}]
            };
            const res = await fetch(CONFIG.apiHost + '/api/v2/analytics/conversations/details/query', {
              method:'POST', headers:{Authorization:'Bearer ' + state.token,'Content-Type':'application/json'}, body:JSON.stringify(body)
            });
            if(!res.ok){ const t=await res.text().catch(()=> ''); throw new Error('Details error: ' + res.status + ' ' + res.statusText + (t?' - ' + t.slice(0,200):'')); }
            const data = await res.json(); const convs = data.conversations||[];
            for(const c of convs) state.convIndex[c.conversationId]=c;
            state.conversations = state.conversations.concat(convs);
          }catch(e){ console.error(e); setStatus('Warning: failed chunk ' + (i+1) + ', continuing‚Ä¶', true); }
          if(i<dateChunks.length-1) await new Promise(function(r){return setTimeout(r,400);});
        }

        await warmQueueCache(state.conversations);

        updateProgress(100, dateChunks.length, dateChunks.length);
        renderResults(state.conversations, from, to);
        setStatus('Found ' + state.conversations.length + ' conversations for the selected period');
        setLoading(false); hideProgress();
      }catch(e){ setStatus('Error fetching conversations: ' + e.message, true); setLoading(false); hideProgress(); }
    }

    function renderResults(conversations, from, to){
      const results=$('results');
      $('dateRange').textContent = fmtDMY(from) + ' to ' + fmtDMY(to||from);
      $('selectedAgent').textContent = state.selectedAgent?.name||'-';
      $('totalConversations').textContent = conversations.length;

      if(!conversations.length){
        results.innerHTML = '<div class="muted" style="text-align:center;padding:40px"><div style="font-size:48px;margin-bottom:12px">üì≠</div><div>No conversations found for ' + (state.selectedAgent?.name||'the selected agent') + '.</div></div>';
        $('resultsSection').style.display='block'; return;
      }

      results.innerHTML = conversations.map(function(conv){
        const participants = conv.participants ? conv.participants.length : 0;
        const media = getConversationMediaTypes(conv);
        const dir = getDirection(conv);
        return '<details><summary><strong>' + conv.conversationId + '</strong> - ' + fmt(conv.conversationStart) + '<span class="muted" style="margin-left:8px;font-size:.9em">(' + participants + ' participants) ‚Ä¢ Media: ' + media + ' ‚Ä¢ Dir: ' + dir + '</span></summary>' + renderConversationDetails(conv) + '</details>';
      }).join('');

      $('resultsSection').style.display='block';
    }

    function renderConversationDetails(conv){
      const mediaType = getMediaType(conv);
      const direction = getDirection(conv);
      const ani = getANI(conv);
      const totalDur = calculateDuration(conv.conversationStart, conv.conversationEnd);
      const transfers = analyzeTransfers(conv);

      let html = '<div class="conversation-header">';
      html += '<div class="info-grid">';
      html += '<div class="info-item"><span class="info-label">Media Type:</span><span class="info-value">' + mediaType + '</span></div>';
      html += '<div class="info-item"><span class="info-label">Customer Number:</span><span class="info-value">' + ani + '</span></div>';
      html += '<div class="info-item"><span class="info-label">Interaction Direction:</span><span class="info-value">' + direction + '</span></div>';
      html += '<div class="info-item"><span class="info-label">Conversation Start:</span><span class="info-value">' + fmt(conv.conversationStart) + '</span></div>';
      html += '<div class="info-item"><span class="info-label">Conversation End:</span><span class="info-value">' + fmt(conv.conversationEnd) + '</span></div>';
      html += '<div class="info-item"><span class="info-label">Duration:</span><span class="info-value">' + formatSeconds(totalDur) + '</span></div>';
      html += '<div class="info-item"><span class="info-label">Transfers (Agent‚ÜíQueue/Agent):</span><span class="info-value"><span class="transfer-count">' + transfers.totalTransfers + '</span></span></div>';
      html += '</div>';

      html += '<div class="transcript-actions" style="display:flex;gap:8px;align-items:center;margin-top:8px">';
      html += '<button id="btn-transcript-' + conv.conversationId + '" onclick="getTranscriptForConversation(\'' + conv.conversationId + '\')">Get Transcript</button>';
      html += '<span id="transcript-status-' + conv.conversationId + '" class="muted"></span>';
      html += '</div>';
      html += '<div id="transcript-' + conv.conversationId + '" style="margin-top:10px;"></div>';
      html += '</div>';

      html += '<h3 style="margin:14px 0 6px;">Customer Journey Timeline</h3>';
      html += '<div class="journey-timeline">';
      html += renderJourneyTimeline(conv, transfers);
      html += '</div>';

      html += '<details><summary>Raw Conversation Data</summary><pre>' + JSON.stringify(conv, null, 2) + '</pre></details>';
      
      return html;
    }

    function renderJourneyTimeline(conv, transferInfo){
      if(!conv.participants || !conv.participants.length) return '<p class="muted">No participant data available</p>';
      const sorted = [...conv.participants].map(function(p){return {p:p,start:getStepStart(p)};})
        .sort(function(a,b){return (a.start?.getTime()??Infinity)-(b.start?.getTime()??Infinity);})
        .map(function(x){return x.p;});

      return sorted.map(function(p,idx){
        const purpose = p.purpose||'unknown';
        const start = getStepStart(p);
        const nextStart = idx<sorted.length-1 ? getStepStart(sorted[idx+1]) : null;
        const queueId = getQueueIdFromParticipant(p);
        const queueName = queueId ? (getQueueName(queueId)||queueId) : null;
        const name = purpose==='acd' ? (queueName?'Queue: ' + queueName:'ACD Queue') : getParticipantName(p);

        let durMs = 0;
        if(p.userId) durMs = getAgentWindow(p).durationMs||0;
        else if(start && nextStart) durMs = Math.max(0, nextStart - start);

        const alertMs = p.userId ? getAlertMsForAgent(p) : null;
        const alertTime = p.userId ? (Math.floor((alertMs||0)/1000) + 's') : 'N/A';

        const transfer = transferInfo.transfers.find(function(t){return t.step===idx;});

        let stepHtml = '<div class="journey-step">';
        stepHtml += '<div class="step-header">Step ' + (idx+1) + ': ' + badge(purpose, name) + (transfer?'<span style="color:#dc2626;margin-left:8px">üîÑ TRANSFERRED</span>':'') + '</div>';
        stepHtml += '<div class="step-details">';
        if(transfer){
          stepHtml += '<div class="transfer-info"><strong>Transfer:</strong> ' + transfer.type + '<br>From: ' + transfer.from + ' ‚Üí To: ' + transfer.to + '<br>Time: ' + fmt(transfer.time) + '</div>';
        }
        stepHtml += '<div class="info-grid">';
        stepHtml += '<div class="info-item"><span class="info-label">Participant Type:</span><span class="info-value">' + getParticipantType(p) + '</span></div>';
        stepHtml += '<div class="info-item"><span class="info-label">Start Time:</span><span class="info-value">' + fmt(start) + '</span></div>';
        if(queueName) stepHtml += '<div class="info-item"><span class="info-label">Queue:</span><span class="info-value">' + queueName + '</span></div>';
        stepHtml += '<div class="info-item"><span class="info-label">Duration:</span><span class="info-value">' + formatSeconds(durMs) + '</span></div>';
        stepHtml += '<div class="info-item"><span class="info-label">Alert Time:</span><span class="info-value">' + alertTime + '</span></div>';
        stepHtml += '<div class="info-item"><span class="info-label">Purpose:</span><span class="info-value">' + purpose + '</span></div>';
        stepHtml += '<div class="info-item"><span class="info-label">Sessions:</span><span class="info-value">' + ((p.sessions&&p.sessions.length)||1) + '</span></div>';
        stepHtml += '</div></div></div>';
        return stepHtml;
      }).join('');
    }

    // ===== Events & Init =====
    $('fetchBtn').addEventListener('click', fetchConversations);
    (function init(){
      const today=new Date(); const weekAgo=new Date(); weekAgo.setDate(today.getDate()-7);
      $('fromDate').value = weekAgo.toISOString().slice(0,10);
      $('toDate').value = today.toISOString().slice(0,10);
      initAuth();
    })();
  </script>
</body>
</html>
