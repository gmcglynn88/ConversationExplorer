<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Interaction Insights - By IPI</title>
  <style>
    :root{
      --primary-color:#63AB8F; --secondary-color:#4A8C7D; --border-color:#DEE2E6;
      --light-bg:#F8F9FA; --card-bg:#FFFFFF; --text-color:#2C3E50; --text-light:#6C757D;
      --pill:#e9f6f0;
    }
    /* Aptos first, then sensible fallbacks */
    body{font-family:"Aptos","Segoe UI",Arial,sans-serif;margin:20px;padding:20px;max-width:1400px;background:var(--light-bg);color:var(--text-color)}
    #logo-container{text-align:center;margin-bottom:20px} #logo{width:300px}
    h1{margin:0 0 16px}
    .card{background:var(--card-bg);border:1px solid var(--border-color);border-radius:12px;padding:24px;margin-top:16px;box-shadow:0 1px 3px rgba(0,0,0,.1)}
    label{display:block;font-weight:600;margin-bottom:6px}
    select,input,button{padding:10px;border:1px solid var(--border-color);border-radius:6px;background:var(--card-bg);font-size:14px}
    button{background:var(--primary-color);color:#fff;font-weight:600;cursor:pointer;transition:background .2s}
    button:hover{background:var(--secondary-color)} button:disabled{background:var(--text-light);cursor:not-allowed}
    .controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:20px 24px;align-items:start}
    .inline{display:grid;grid-template-columns:1fr auto 1fr;gap:16px;align-items:center} .inline span{color:var(--text-light)}
    .full-width-btn{width:100%;padding:14px 18px;font-size:16px;margin-top:12px}
    .muted{color:var(--text-light)} .mono{font-family:ui-monospace,Consolas,Menlo,monospace}
    .user-info,.conversation-header,.transcript-summary{background:transparent;border:2px solid var(--primary-color);border-radius:10px;padding:16px;margin:12px 0}
    details{background:var(--light-bg);border:1px solid var(--border-color);border-radius:8px;padding:16px;margin:12px 0}
    details>summary{cursor:pointer;font-weight:600}
    pre{background:#1f2937;color:#f3f4f6;padding:16px;border-radius:6px;overflow:auto;font-size:12px}
    .stats{display:flex;gap:16px;margin:16px 0}
    .stat-card{flex:1;border:1px solid var(--border-color);border-radius:8px;padding:16px;text-align:center;background:var(--card-bg)}
    .stat-number{font-size:22px;color:#63AB8F;font-weight:700}
    .journey-timeline{margin:20px 0 8px;padding-left:20px;border-left:3px solid var(--primary-color)}
    .journey-step{margin-bottom:18px;position:relative}
    .journey-step:before{content:'';position:absolute;left:-26px;top:0;width:16px;height:16px;border-radius:50%;background:var(--primary-color)}
    .step-header{font-weight:700;color:var(--secondary-color);margin-bottom:8px}
    .step-details{background:var(--card-bg);border:1px solid var(--border-color);border-radius:6px;padding:12px}
    .info-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:12px}
    .info-item{display:flex;justify-content:space-between;border-bottom:1px solid var(--border-color);padding:6px 0}
    .info-label{font-weight:600;min-width:150px}
    .participant-badge{display:inline-block;padding:4px 8px;border-radius:4px;font-size:12px;font-weight:600;margin:2px;border:1px solid var(--border-color);background:#fff}
    .badge-customer{border-color:#a7e3c6;color:#1f7255}
    .badge-agent{background:#dbeafe;color:#1e40af}
    .badge-queue{background:#fde7ff;color:#7c3aed}
    .transfer-info{background:#fff7ed;border:1px solid var(--border-color);border-radius:6px;padding:8px;margin:8px 0}
    .transfer-count{background:#fee2e2;color:#b91c1c;padding:2px 8px;border-radius:6px;font-weight:700}
    .progress-bar{width:100%;height:8px;background:var(--border-color);border-radius:4px;overflow:hidden;margin:10px 0}
    .progress-fill{height:100%;background:var(--primary-color);transition:width .3s}
    .t-summary-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:10px 16px}
    .t-kv{display:flex;gap:10px;justify-content:space-between}.t-kv .k{font-weight:700}
    .pill{display:inline-block;background:var(--pill);border:1px solid var(--border-color);border-radius:999px;padding:2px 8px;font-size:12px;margin-right:6px}
    .transcript-table{width:100%;border-collapse:collapse;margin-top:10px}
    .transcript-table th,.transcript-table td{border-bottom:1px solid var(--border-color);padding:8px 10px;vertical-align:top}
    .transcript-table th{background:var(--primary-color);color:#fff;text-align:left}
    .sentiment-positive{color:#16a34a;font-weight:700}
    .sentiment-negative{color:#dc2626;font-weight:700}
    .sentiment-neutral{color:#f59e0b;font-weight:700}
    .empathy-positive{color:#16a34a;font-weight:700}
    .empathy-negative{color:#dc2626;font-weight:700} /* Unhelpful = red */
    .confidence-high{color:#16a34a;font-weight:700}
    .confidence-medium{color:#f59e0b;font-weight:700}
    .confidence-low{color:#dc2626;font-weight:700}
    .loading{opacity:.6;pointer-events:none}
    .future-date{color:#ccc;cursor:not-allowed}
    
    /* New styles for transfer reporting */
    .tab-container { margin-top: 20px; }
    .tab-buttons { display: flex; border-bottom: 1px solid var(--border-color); margin-bottom: 20px; }
    .tab-button { padding: 10px 20px; background: none; border: none; cursor: pointer; font-weight: 600; color: var(--text-light); border-bottom: 3px solid transparent; transition: all 0.2s; }
    .tab-button.active { color: var(--primary-color); border-bottom-color: var(--primary-color); }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    
    .transfer-table { width: 100%; border-collapse: collapse; margin-top: 16px; }
    .transfer-table th, .transfer-table td { border: 1px solid var(--border-color); padding: 12px; text-align: left; }
    .transfer-table th { background-color: var(--primary-color); color: white; font-weight: 600; }
    .transfer-table tr:nth-child(even) { background-color: var(--light-bg); }
    .transfer-table tr:hover { background-color: #f0f7f4; }
    
    .transfer-stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 20px; }
    .transfer-stat-card { background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 16px; text-align: center; }
    .transfer-stat-number { font-size: 24px; color: var(--primary-color); font-weight: 700; margin-bottom: 8px; }
    .transfer-stat-label { font-size: 14px; color: var(--text-light); }
    
    .transfer-flow { display: flex; align-items: center; justify-content: center; margin: 10px 0; }
    .transfer-node { padding: 8px 16px; border-radius: 6px; background: var(--light-bg); border: 1px solid var(--border-color); font-weight: 600; }
    .transfer-arrow { margin: 0 12px; color: var(--primary-color); font-size: 18px; }
    
    .filter-controls { display: flex; gap: 12px; margin-bottom: 16px; flex-wrap: wrap; }
    .filter-controls select, .filter-controls input { flex: 1; min-width: 150px; }
    
    /* Queue Transfer Matrix Styles */
    .queue-transfer-matrix { overflow-x: auto; margin-top: 20px; }
    .matrix-table { border-collapse: collapse; width: 100%; min-width: 600px; }
    .matrix-table th, .matrix-table td { border: 1px solid var(--border-color); padding: 10px; text-align: center; }
    .matrix-table th { background-color: var(--primary-color); color: white; font-weight: 600; }
    .matrix-table th.from-header { background-color: var(--secondary-color); }
    .matrix-table th.to-header { background-color: var(--primary-color); }
    .matrix-table td.from-label { background-color: var(--light-bg); font-weight: 600; text-align: left; }
    .matrix-table tr:hover td { background-color: #f0f7f4; }
    .matrix-count { font-weight: 600; color: var(--text-color); }
    .matrix-high { background-color: #fee2e2 !important; }
    .matrix-medium { background-color: #fef3c7 !important; }
    .matrix-low { background-color: #d1fae5 !important; }
    
    .agent-selector { margin-bottom: 16px; }
    .agent-selector label { display: inline-block; margin-right: 12px; }
    .agent-selector select { min-width: 200px; }
  </style>
</head>
<body>
  <div id="logo-container">
    <img id="logo" src="https://raw.githubusercontent.com/gmcglynn88/ExternalWorkCreation/main/Consultinglogo.png" alt="Company Logo">
  </div>
  <h1>Interaction Insights - By IPI</h1>
  <button id="signinBtn" style="display:none;margin-bottom:12px;">Sign in to Genesys Cloud</button>

  <div id="authStatus" class="card" style="display:none;">
    <div style="text-align:center;padding:20px;">
      <div style="font-size:18px;color:var(--secondary-color);margin-bottom:8px;">üîê Authenticating‚Ä¶</div>
      <div class="muted">Connecting to Genesys Cloud</div>
    </div>
  </div>

  <div id="mainContent" style="display:none;">
    <div class="card">
      <h2 style="margin:0 0 12px;">Select Agent & Date Range</h2>
      <div class="controls">
        <div>
          <label for="agentSelect">Select Agent</label>
          <select id="agentSelect"><option>Loading users‚Ä¶</option></select>
          <input id="agentFilter" type="text" placeholder="Filter users by name" style="margin-top:8px"/>
          <div class="user-info" id="selectedAgentInfo" style="display:none;">
            <strong>Selected Agent:</strong> <span id="selectedAgentName">None</span>
          </div>
        </div>
        <div>
          <label>Date Range</label>
          <div class="inline">
            <input id="fromDate" type="date"/>
            <span>to</span>
            <input id="toDate" type="date"/>
          </div>
          <label style="display:flex;align-items:center;gap:8px;margin-top:8px;">
            <input id="autoChunk" type="checkbox" checked/> Auto-split large date ranges (recommended)
          </label>
        </div>
      </div>
      <button id="fetchBtn" class="full-width-btn">Fetch Conversations</button>
    </div>

    <div id="statusMessage" class="muted" style="margin-top:10px;"></div>
    <div id="errorMessage" style="color:#dc2626;margin-top:6px;"></div>

    <div id="progressSection" style="display:none;">
      <div class="card">
        <h3 style="margin:0 0 8px;">Fetching Conversations</h3>
        <div class="muted" id="chunkInfo">Processing date range in smaller chunks‚Ä¶</div>
        <div class="progress-bar"><div class="progress-fill" id="progressFill" style="width:0%"></div></div>
        <div style="display:flex;justify-content:space-between;font-size:14px" class="muted">
          <span id="progressText">0%</span><span id="chunkText">Chunk 0/0</span>
        </div>
      </div>
    </div>

    <div class="tab-container">
      <div class="tab-buttons">
        <button class="tab-button active" data-tab="conversations">Conversations</button>
        <button class="tab-button" data-tab="transfers">Transfer Reporting</button>
        <button class="tab-button" data-tab="queue-transfer-matrix">Queue Transfer Matrix</button>
      </div>
      
      <div id="conversations-tab" class="tab-content active">
        <div id="resultsSection" style="display:none;">
          <div class="card">
            <h2 style="margin:0 0 12px;">Conversation Results</h2>
            <div class="stats">
              <div class="stat-card"><div class="stat-number" id="totalConversations">0</div><div class="stat-label">Total Conversations</div></div>
              <div class="stat-card"><div class="stat-number" id="dateRange">-</div><div class="stat-label">Date Range</div></div>
              <div class="stat-card"><div class="stat-number" id="selectedAgent">-</div><div class="stat-label">Selected Agent</div></div>
            </div>
            <div id="results"></div>
          </div>
        </div>
      </div>
      
      <div id="transfers-tab" class="tab-content">
        <div class="card">
          <h2 style="margin:0 0 12px;">Transfer Reporting</h2>
          <div class="filter-controls">
            <select id="transferFilter">
              <option value="all">All Transfers</option>
              <option value="agent-to-agent">Agent ‚Üí Agent</option>
              <option value="queue-to-queue">Queue ‚Üí Queue</option>
            </select>
            <input type="text" id="transferSearch" placeholder="Search by conversation ID, queue, or agent">
          </div>
          
          <div id="transferStats" class="transfer-stats">
            <!-- Will be populated with transfer statistics -->
          </div>
          
          <div id="transferTableContainer">
            <table class="transfer-table">
              <thead>
                <tr>
                  <th>Conversation ID</th>
                  <th>From</th>
                  <th>To</th>
                  <th>Transfer Type</th>
                  <th>Time</th>
                  <th>Duration</th>
                </tr>
              </thead>
              <tbody id="transferTableBody">
                <!-- Will be populated with transfer data -->
              </tbody>
            </table>
          </div>
          
          <div id="noTransfersMessage" style="display:none; text-align:center; padding:40px;">
            <div style="font-size:48px;margin-bottom:12px">üîÑ</div>
            <div>No transfers found for the selected criteria.</div>
          </div>
        </div>
      </div>
      
      <div id="queue-transfer-matrix-tab" class="tab-content">
        <div class="card">
          <h2 style="margin:0 0 12px;">Queue Transfer Matrix</h2>
          
          <div class="agent-selector">
            <label for="matrixAgentSelect">Show transfers for:</label>
            <select id="matrixAgentSelect">
              <option value="all">All Agents</option>
              <!-- Agent options will be populated dynamically -->
            </select>
          </div>
          
          <div id="matrixStats" class="transfer-stats">
            <!-- Will be populated with matrix statistics -->
          </div>
          
          <div id="matrixContainer" class="queue-transfer-matrix">
            <!-- Will be populated with the queue transfer matrix -->
          </div>
          
          <div id="noMatrixDataMessage" style="display:none; text-align:center; padding:40px;">
            <div style="font-size:48px;margin-bottom:12px">üìä</div>
            <div>No queue transfer data available for the selected criteria.</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ===== Config (Ireland) =====
    const CONFIG = {
      clientId: 'fe305808-b368-4547-8af9-325d28d552bb',
      redirectUri: 'https://gmcglynn88.github.io/ConversationExplorer/',
      loginHost: 'https://login.mypurecloud.ie',
      apiHost: 'https://api.mypurecloud.ie'
    };

    // ===== State =====
    const state = { 
      token:null, 
      users:[], 
      queues:{}, 
      conversations:[], 
      selectedAgent:null, 
      convIndex:{},
      allTransfers: [], // New state for storing all transfers
      queueTransfers: [] // New state for queue-to-queue transfers
    };

    // ===== Utils =====
    const $ = id => document.getElementById(id);
    const setStatus = (msg,err=false)=>{ $('statusMessage').textContent = err?'':(msg||''); $('errorMessage').textContent = err?(msg||''):''; };
    const fmt = d => { if(!d) return 'N/A'; try{return new Date(d).toLocaleString()}catch{return 'N/A'} };
    const fmtDMY = s => { if(!s||s.length<10) return s||''; const [y,m,d]=s.slice(0,10).split('-'); return `${d}-${m}-${y}`; };
    const formatSeconds = ms => { if(!ms) return '0s'; const s=Math.floor(ms/1000), m=Math.floor(s/60), h=Math.floor(m/60); if(h) return `${h}h ${m%60}m ${s%60}s`; if(m) return `${m}m ${s%60}s`; return `${s}s`; };
    const mmss = ms => { const totalSeconds = Math.max(0, Math.floor((+ms||0)/1000)); const minutes = Math.floor(totalSeconds / 60); const seconds = totalSeconds % 60; return String(minutes).padStart(2, '0') + ':' + String(seconds).padStart(2, '0'); };
    const calculateDuration = (a,b)=>{ if(!a||!b) return 0; return new Date(b)-new Date(a); };
    function showMain(){ $('authStatus').style.display='none'; $('mainContent').style.display='block'; }
    function setLoading(v){ $('mainContent').classList.toggle('loading', !!v); }
    function updateProgress(p,cur,total){ $('progressFill').style.width = `${p}%`; $('progressText').textContent = `${Math.round(p)}%`; $('chunkText').textContent = `Chunk ${cur}/${total}`; }
    function showProgress(){ $('progressSection').style.display='block'; $('resultsSection').style.display='none'; }
    function hideProgress(){ $('progressSection').style.display='none'; }

    // ===== Date Range Limiting =====
    function setupDateLimits() {
      const today = new Date().toISOString().split('T')[0];
      $('fromDate').max = today; $('toDate').max = today;
      $('fromDate').addEventListener('change', function() {
        if (this.value > today) this.value = today;
        if ($('toDate').value && this.value > $('toDate').value) $('toDate').value = this.value;
      });
      $('toDate').addEventListener('change', function() {
        if (this.value > today) this.value = today;
        if ($('fromDate').value && this.value < $('fromDate').value) $('fromDate').value = this.value;
      });
    }

    // ===== Tab Management =====
    function setupTabs() {
      const tabButtons = document.querySelectorAll('.tab-button');
      const tabContents = document.querySelectorAll('.tab-content');
      
      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          // Remove active class from all buttons and contents
          tabButtons.forEach(btn => btn.classList.remove('active'));
          tabContents.forEach(content => content.classList.remove('active'));
          
          // Add active class to clicked button and corresponding content
          button.classList.add('active');
          const tabId = button.getAttribute('data-tab') + '-tab';
          document.getElementById(tabId).classList.add('active');
        });
      });
    }

    // ===== Auth (Implicit) ‚Äî auto-redirect once per tab if no token =====
    function parseTokenFromHash(){
      const params = new URLSearchParams(location.hash.replace(/^#/, ''));
      return { token: params.get('access_token'), error: params.get('error'), errorDescription: params.get('error_description') };
    }
    function authUrl(){
      return `${CONFIG.loginHost}/oauth/authorize?client_id=${encodeURIComponent(CONFIG.clientId)}&response_type=token&redirect_uri=${encodeURIComponent(CONFIG.redirectUri)}`;
    }
    function initAuth(){
      const {token, error} = parseTokenFromHash();
      if(location.hash) history.replaceState(null,'',location.pathname);

      if(token){
        sessionStorage.removeItem('gc_auto_auth_attempted');
        state.token = token; showMain(); setupDateLimits(); setupTabs(); fetchAllUsers();
        return;
      }

      // If we don't have a token yet: try auto sign-in once per tab
      const attempted = sessionStorage.getItem('gc_auto_auth_attempted');
      if(!attempted && !error){
        sessionStorage.setItem('gc_auto_auth_attempted','1');
        location.assign(authUrl());
        return;
      }

      // Fallback button if auto redirect didn't complete (or user denied)
      $('signinBtn').style.display = 'inline-block';
      $('signinBtn').onclick = () => { sessionStorage.setItem('gc_auto_auth_attempted','1'); location.assign(authUrl()); };
      $('authStatus').style.display = 'none';
    }

    // ===== API helper =====
    async function api(path){
      if(!state.token) throw new Error('Not authenticated');
      const res = await fetch(`${CONFIG.apiHost}${path}`, { headers:{Authorization:`Bearer ${state.token}`} });
      if(res.status===401||res.status===403) throw new Error(`Authentication error (${res.status}). Please refresh.`);
      if(!res.ok){ const t = await res.text().catch(()=> ''); throw new Error(`API Error: ${res.status} ${res.statusText}${t?` - ${t.slice(0,200)}`:''}`); }
      return res.json();
    }

    // ===== Users =====
    async function fetchAllUsers(){
      try{
        setStatus('Loading users‚Ä¶'); setLoading(true);
        let all=[], page=1, size=100;
        while(true){
          const data = await api(`/api/v2/users?pageSize=${size}&pageNumber=${page}`);
          const ents = data?.entities||[]; all = all.concat(ents);
          if(!data?.nextUri || ents.length<size) break; page++;
        }
        state.users = all.map(u=>({id:u.id,name:u.name||'',email:u.email||''})).sort((a,b)=>a.name.localeCompare(b.name));
        populateUserSelect(state.users);
        populateMatrixAgentSelect(state.users);
        setStatus(`Loaded ${state.users.length} users`); setLoading(false);
      }catch(e){ setStatus(`Failed to load users: ${e.message}`, true); setLoading(false); $('agentSelect').innerHTML='<option>Failed to load users</option>'; }
    }
    function populateUserSelect(users){
      const sel=$('agentSelect');
      sel.innerHTML = '<option value="">Select an agent‚Ä¶</option>' + users.map(u=>`<option value="${u.id}">${u.name||'(Unnamed)'}</option>`).join('');
      sel.onchange=()=>{ const u = users.find(x=>x.id===sel.value); state.selectedAgent=u||null; if(u){ $('selectedAgentName').textContent=u.name||'(Unnamed)'; $('selectedAgentInfo').style.display='block'; } else { $('selectedAgentInfo').style.display='none'; } };
    }
    
    function populateMatrixAgentSelect(users) {
      const sel = $('matrixAgentSelect');
      sel.innerHTML = '<option value="all">All Agents</option>' + 
        users.map(u => `<option value="${u.id}">${u.name || '(Unnamed)'}</option>`).join('');
    }
    
    $('agentFilter').addEventListener('input', function(){
      const q = this.value.trim().toLowerCase();
      populateUserSelect(q ? state.users.filter(u=>(u.name||'').toLowerCase().includes(q)) : state.users);
    });

    // ===== Chunking =====
    function chunks(start,end,days){
      const out=[]; const s=new Date(start), e=new Date(end); let cur=new Date(s);
      while(cur<=e){ let ce=new Date(cur); ce.setDate(ce.getDate()+days-1); if(ce>e) ce=new Date(e);
        out.push({start:cur.toISOString().slice(0,10), end:ce.toISOString().slice(0,10)}); cur.setDate(cur.getDate()+days);
      } return out;
    }
    function optimalDays(start,end){
      const s=new Date(start), e=new Date(end), total=Math.ceil((e-s)/(1000*60*60*24))+1;
      if(total<=7) return 7; if(total<=30) return 7; if(total<=90) return 5; if(total<=180) return 3; return 2;
    }

    // ===== Queue helpers =====
    function getQueueIdFromParticipant(p){ 
      if(p.queueId) return p.queueId; 
      for(const s of (p.sessions||[])) {
        if(s.queueId) return s.queueId;
        // Also check segments for queue information
        for(const seg of (s.segments||[])) {
          if(seg.queueId) return seg.queueId;
        }
      }
      return null; 
    }
    
    function getQueueName(id){ 
      if (!id) return null;
      return state.queues[id] || null; 
    }
    
    async function fetchQueueName(id){ 
      if(!id || state.queues[id]) return; 
      try{ 
        const q = await api(`/api/v2/routing/queues/${id}`); 
        state.queues[id] = q?.name || `Queue ${id}`; 
      } catch(e) { 
        console.warn(`Could not fetch queue name for ${id}:`, e);
        state.queues[id] = `Queue ${id}`; 
      } 
    }
    
    async function warmQueueCache(convs){
      const set = new Set(); 
      for(const c of convs) {
        for(const p of (c.participants||[])){ 
          const id = getQueueIdFromParticipant(p); 
          if(id) set.add(id); 
        }
      }
      await Promise.all([...set].filter(id => !state.queues[id]).map(fetchQueueName));
    }

    // ===== Conversation helpers =====
    function firstSession(c){ for(const p of (c.participants||[])) for(const s of (p.sessions||[])) return s; return null; }
    function getMediaType(c){ return (firstSession(c)?.mediaType)||'Unknown'; }
    function getDirection(c){ return firstSession(c)?.direction || c.originatingDirection || 'Unknown'; }
    function getConversationMediaTypes(c){ const t=new Set(); for(const p of (c.participants||[])) for(const s of (p.sessions||[])) if(s.mediaType) t.add(s.mediaType); return [...t].join(', ')||getMediaType(c); }
    function getANI(c){
      for(const p of (c.participants||[])) for(const s of (p.sessions||[])){
        if((s.mediaType||'').toLowerCase()!=='voice') continue;
        const dir=(s.direction||c.originatingDirection||'').toLowerCase();
        if(dir==='inbound') return s.ani||s.addressFrom||s.otherAddress||s.remote||'Unknown';
      }
      const s=firstSession(c); return s?.ani||s?.addressFrom||s?.otherAddress||s?.remote||'Unknown';
    }
    function getStepStart(p){
      let t=[]; for(const s of (p.sessions||[])){
        if(s.startTime){ const v=+new Date(s.startTime); if(!isNaN(v)) t.push(v); }
        for(const seg of (s.segments||[])){
          if(seg.segmentStart){ const v=+new Date(seg.segmentStart); if(!isNaN(v)) t.push(v); }
          for(const ev of (seg.events||[])) if(ev.eventTime){ const v=+new Date(ev.eventTime); if(!isNaN(v)) t.push(v); }
        }
      }
      return t.length? new Date(Math.min(...t)) : null;
    }
    function getAgentWindow(p){
      let s=[],e=[]; for(const ss of (p.sessions||[])){
        for(const seg of (ss.segments||[])){
          if(seg.segmentStart){ const v=+new Date(seg.segmentStart); if(!isNaN(v)) s.push(v); }
          if(seg.segmentEnd){ const v=+new Date(seg.segmentEnd); if(!isNaN(v)) e.push(v); }
        }
      }
      if(!s.length||!e.length) return {durationMs:0}; return {durationMs: Math.max(...e)-Math.min(...s)};
    }
    function getAlertMsForAgent(p){
      if(!p?.userId) return 0; let total=0; const add=v=>{ if(v==null||isNaN(v))return; const ms=(v>120)?v:v*1000; total+=ms; };
      for(const s of (p.sessions||[])){
        if(Array.isArray(s.metrics)) for(const m of s.metrics) if(m?.name==='tAlert') add(m.value??m.durationMs);
        for(const seg of (s.segments||[])){
          if(Array.isArray(seg.metrics)) for(const m of seg.metrics) if(m?.name==='tAlert') add(m.value??m.durationMs);
          for(const ev of (seg.events||[])) if(Array.isArray(ev.metrics)) for(const m of ev.metrics) if(m?.name==='tAlert') add(m.value??m.durationMs);
        }
      }
      return total;
    }

    // ===== IMPROVED TRANSFER ANALYSIS =====
    function analyzeTransfers(c){
      const transfers = [];
      let totalTransfers = 0;
      
      // Build a timeline of all participant engagements with their queue context
      const timeline = [];
      let currentQueue = null;
      
      for(const p of (c.participants||[])){
        const queueId = getQueueIdFromParticipant(p);
        const startTime = getStepStart(p);
        
        if(startTime) {
          // Update current queue context
          if(queueId) {
            currentQueue = queueId;
          }
          
          timeline.push({
            time: startTime.getTime(),
            participant: p,
            queueId: queueId,
            userId: p.userId,
            purpose: p.purpose,
            currentQueue: currentQueue // Track the queue context at this point
          });
        }
      }
      
      // Sort by time
      timeline.sort((a, b) => a.time - b.time);
      
      // Analyze transfers between consecutive entries
      for(let i = 1; i < timeline.length; i++) {
        const prev = timeline[i-1];
        const curr = timeline[i];
        
        // Skip if we don't have proper queue/user info
        if(!prev || !curr) continue;
        
        // Determine FROM information - use queue context if available
        let fromId = null;
        let fromType = null;
        let fromQueueId = null;
        
        if(prev.userId) {
          // Agent transfer - use the queue they were in
          fromId = prev.currentQueue || prev.userId;
          fromType = prev.currentQueue ? 'Queue' : 'Agent';
          fromQueueId = prev.currentQueue;
        } else if(prev.queueId) {
          // Direct queue transfer
          fromId = prev.queueId;
          fromType = 'Queue';
          fromQueueId = prev.queueId;
        } else {
          // Unknown source
          fromId = prev.purpose || 'Unknown';
          fromType = prev.purpose || 'Unknown';
        }
        
        // Determine TO information
        let toId = null;
        let toType = null;
        let toQueueId = null;
        
        if(curr.userId) {
          // Transfer to agent - use the queue they're in
          toId = curr.currentQueue || curr.userId;
          toType = curr.currentQueue ? 'Queue' : 'Agent';
          toQueueId = curr.currentQueue;
        } else if(curr.queueId) {
          // Transfer to queue
          toId = curr.queueId;
          toType = 'Queue';
          toQueueId = curr.queueId;
        } else {
          // Unknown destination
          toId = curr.purpose || 'Unknown';
          toType = curr.purpose || 'Unknown';
        }
        
        // Only count as transfer if FROM and TO are different
        if(fromId !== toId) {
          let transferType = null;
          
          // Determine transfer type
          if(fromType === 'Agent' && toType === 'Agent') {
            transferType = 'Agent ‚Üí Agent';
          } else {
            // Everything else is considered Queue ‚Üí Queue
            // This includes Agent‚ÜíQueue, Queue‚ÜíAgent, and Queue‚ÜíQueue
            transferType = 'Queue ‚Üí Queue';
            
            // For the matrix, we need to ensure we have queue IDs
            if(!fromQueueId && fromType === 'Agent') {
              // If agent doesn't have a queue context, we can't track this in matrix
              continue;
            }
            if(!toQueueId && toType === 'Agent') {
              // If destination agent doesn't have queue context, we can't track this in matrix
              continue;
            }
          }
          
          if(transferType) {
            totalTransfers++;
            transfers.push({
              step: i,
              from: fromType,
              to: toType,
              fromId: fromId,
              toId: toId,
              fromQueueId: fromQueueId, // For matrix tracking
              toQueueId: toQueueId,     // For matrix tracking
              time: new Date(curr.time).toISOString(),
              type: transferType,
              conversationId: c.conversationId,
              duration: i < timeline.length-1 ? (timeline[i+1].time - curr.time) : 0
            });
          }
        }
      }
      
      return {totalTransfers, transfers};
    }

    function getParticipantName(p){
      if(p.purpose==='customer') return 'Customer';
      if(p.userId){ const u=state.users.find(x=>x.id===p.userId); return u?u.name:`Agent (${p.userId})`; }
      if(p.purpose==='acd') return 'ACD Queue';
      if(p.purpose==='ivr') return 'IVR System';
      if(p.purpose==='external') return 'External System';
      return p.purpose||'Unknown';
    }
    function getParticipantType(p){
      if(p.purpose==='customer') return 'Customer';
      if(p.userId) return 'Agent';
      if(p.purpose==='acd') return 'Queue';
      if(p.purpose==='ivr') return 'IVR System';
      if(p.purpose==='external') return 'External';
      return p.purpose||'Unknown';
    }
    function badge(purpose,name){
      const cls = {'customer':'badge-customer','user':'badge-agent','acd':'badge-queue','ivr':'badge-ivr','external':'badge-system','queue':'badge-queue'}[purpose]||'badge-system';
      return '<span class="participant-badge ' + cls + '">' + name + '</span>';
    }

    // ===== Transcript helpers (robust + numeric‚Üílabel) =====
    function normaliseRole(v){
      const s=(v||'').toString().toLowerCase();
      if(['internal','agent','user'].includes(s)) return 'internal';
      if(['external','customer','participant','caller','callee'].includes(s)) return 'external';
      return s||'external';
    }
    function labelToScore(v){
      if(v==null) return null;
      if(typeof v==='number') return v;
      const s=v.toString().toUpperCase();
      if(s.includes('POS')) return 0.6;
      if(s.includes('NEG')) return -0.6;
      if(s.includes('NEU')) return 0;
      const n=parseFloat(v); return isNaN(n)?null:n;
    }
    function coerceMs(x){
      const n=Number(x); if(!isNaN(n)) return n;
      const d=+new Date(x); return isNaN(d)?null:d;
    }

    function extractSignals(parsed){
      const out=[]; const buckets=[];
      if(parsed?.analytics) buckets.push(parsed.analytics);
      if(Array.isArray(parsed?.transcripts)){
        for(const tr of parsed.transcripts){ if(tr?.analytics) buckets.push(tr.analytics); }
      }
      for(const a of buckets){
        if(!a) continue;
        if(Array.isArray(a.sentiment)){
          for(const s of a.sentiment){
            out.push({kind:'sentiment',role:normaliseRole(s.participant||s.participantPurpose),startTimeMs:coerceMs(s.startTimeMs),endTimeMs:(s.duration?.milliseconds!=null)?(coerceMs(s.startTimeMs)+Number(s.duration.milliseconds)):coerceMs(s.endTimeMs),value:labelToScore(s.sentiment??s.score??s.value??s.level)});
          }
        }
        if(Array.isArray(a.empathy)){
          for(const e of a.empathy){
            const v=e.empathy??e.score??e.value;
            out.push({kind:'empathy',role:normaliseRole(e.participant||e.participantPurpose),startTimeMs:coerceMs(e.startTimeMs),endTimeMs:(e.duration?.milliseconds!=null)?(coerceMs(e.startTimeMs)+Number(e.duration.milliseconds)):coerceMs(e.endTimeMs),value:(typeof v==='number')?v:labelToScore(v)});
          }
        }
      }
      return out.filter(s=>s.role && s.startTimeMs!=null);
    }

    function processPhrases(parsed){
      let phrases=[];
      if(Array.isArray(parsed?.transcripts)){
        parsed.transcripts.forEach(tr=>{ if(Array.isArray(tr.phrases)) phrases=phrases.concat(tr.phrases); });
      }
      if(Array.isArray(parsed?.phrases)) phrases=phrases.concat(parsed.phrases);
      return phrases.map(ph=>{
        const start=coerceMs(ph.startTimeMs??ph.startTime??ph.offsetMs??ph.offset);
        const end=coerceMs(ph.endTimeMs??ph.endTime??(start!=null?start+3000:null));
        const role=normaliseRole(ph.participantPurpose??ph.participant??ph.role);
        const text=ph.decoratedText??ph.text??ph.transcript??'';
        const conf=(typeof ph.confidence==='number')?ph.confidence
                 :(typeof ph.confidenceScore==='number')?ph.confidenceScore
                 :(typeof ph.asrConfidence==='number')?ph.asrConfidence:null;
        const directSent=ph.sentimentScore??ph.sentiment??ph.analytics?.sentiment??null;
        const directEmp =ph.empathyScore??ph.empathy??ph.analytics?.empathy??null;
        return {
          participantPurpose: role||'external',
          decoratedText: text,
          startTimeMs: start ?? 0,
          endTimeMs: end ?? ((start ?? 0)+3000),
          sentimentDirect: labelToScore(directSent),
          empathyDirect: (typeof directEmp==='number')?directEmp:labelToScore(directEmp),
          confidence: (typeof conf==='number'?conf:null),
          participantId: ph.participantId,
          userIds: ph.userIds||[],
          externalContactIds: ph.externalContactIds||[]
        };
      }).filter(p=>p.decoratedText && p.startTimeMs!=null).sort((a,b)=>a.startTimeMs-b.startTimeMs);
    }

    const SENTIMENT_POS = 0.15;
    const SENTIMENT_NEG = -0.15;
    const EMPATHY_GOOD  = 0.20;

    function sentimentToLabel(v){
      if (v == null || isNaN(v)) return {label:'-', css:'sentiment-neutral'};
      if (v > SENTIMENT_POS)     return {label:'Positive', css:'sentiment-positive'};
      if (v < SENTIMENT_NEG)     return {label:'Negative', css:'sentiment-negative'};
      return {label:'Neutral', css:'sentiment-neutral'};
    }
    function empathyToLabel(v){
      if (v == null || isNaN(v)) return {label:'-', css:''};
      return (v > EMPATHY_GOOD)
        ? {label:'Empathetic', css:'empathy-positive'}
        : {label:'Unhelpful',  css:'empathy-negative'}; // now red
    }

    // ===== Transcript fetch & render =====
    async function getTranscriptForConversation(conversationId){
      const statusEl = document.querySelector('#transcript-status-' + conversationId);
      const container = document.querySelector('#transcript-' + conversationId);
      const btn = document.querySelector('#btn-transcript-' + conversationId);
      if(!state.token){ alert('Not authenticated'); return; }
      const conv = state.convIndex[conversationId]; if(!conv){ statusEl.textContent='Conversation not found in state.'; return; }
      const commId = findCommunicationsIdFromDetails(conv);
      if(!commId){ statusEl.textContent='No sessionId found to use as communicationsId.'; return; }
      try{
        btn.disabled=true; statusEl.textContent='Requesting transcript URL‚Ä¶';
        const urlRes = await fetch(CONFIG.apiHost + '/api/v2/speechandtextanalytics/conversations/' + conversationId + '/communications/' + commId + '/transcripturl', {headers:{Authorization:'Bearer ' + state.token}});
        if(!urlRes.ok){ const t=await urlRes.text().catch(()=> ''); throw new Error('Transcript URL error: ' + urlRes.status + ' ' + urlRes.statusText + (t?' - ' + t.slice(0,200):'')); }
        const {url:presigned} = await urlRes.json(); if(!presigned) throw new Error('No URL in transcript response.');
        statusEl.textContent='Downloading transcript‚Ä¶';
        const raw = await fetch(presigned); if(!raw.ok) throw new Error('Transcript download failed: ' + raw.status + ' ' + raw.statusText);
        const text = await raw.text(); let parsed=null; try{ parsed=JSON.parse(text);}catch{}
        statusEl.textContent='Rendering transcript‚Ä¶';
        renderTranscript(container, parsed, text, conv);
        statusEl.textContent='Transcript loaded.';
      }catch(e){
        console.error(e); statusEl.innerHTML='‚ö†Ô∏è ' + e.message + '<span class="muted"> ‚Äî If this is a CORS issue, try opening the raw URL in a new tab.</span>';
      }finally{ btn.disabled=false; }
    }
    window.getTranscriptForConversation = getTranscriptForConversation;

    const SIGNAL_ANCHOR_TOL_MS = 1500;

    function renderTranscript(container, parsed, rawText, conversation){
      const escapeHtml = s => (s||'').toString().replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[c]));

      const phrases = processPhrases(parsed);
      const signals = extractSignals(parsed);
      if (!phrases.length){
        container.innerHTML = '<div class="muted">No transcript phrases found.</div>' +
          '<details><summary>Show Raw Data for Debugging</summary><pre>' + escapeHtml(typeof rawText==='string'?rawText:JSON.stringify(parsed,null,2)) + '</pre></details>';
        return;
      }

      const enriched = phrases.map(p=>({
        ...p,
        sentiment: (p.sentimentDirect!=null)?Number(p.sentimentDirect):null,
        empathy:   (p.empathyDirect!=null)?Number(p.empathyDirect):null
      }));

      const sentiments = signals.filter(s=>s.kind==='sentiment' && s.role==='external');
      const empathies  = signals.filter(s=>s.kind==='empathy'  && s.role==='internal');

      function assignNearest(signalsArr, role, field){
        for(const s of signalsArr){
          let bestIdx=-1, bestDelta=Infinity;
          for(let i=0;i<enriched.length;i++){
            const p=enriched[i];
            if(p.participantPurpose!==role) continue;
            const d=Math.abs((p.startTimeMs??0) - (s.startTimeMs??0));
            if(d<=SIGNAL_ANCHOR_TOL_MS && d<bestDelta){ bestDelta=d; bestIdx=i; }
          }
          if(bestIdx>=0){
            if(enriched[bestIdx][field]==null) enriched[bestIdx][field]=s.value;
          }
        }
      }

      assignNearest(sentiments,'external','sentiment');
      assignNearest(empathies,'internal','empathy');

      const nameMap = mapParticipantNames(conversation);
      const { internal, external } = participantsByType(conversation);

      function sentimentCell(p){
        if(p.participantPurpose!=='external' || p.sentiment==null) return '-';
        const {label, css} = sentimentToLabel(Number(p.sentiment));
        return `<span class="${css}">${label}</span>`;
      }
      function empathyCell(p){
        if(p.participantPurpose!=='internal' || p.empathy==null) return '-';
        const {label, css} = empathyToLabel(Number(p.empathy));
        return `<span class="${css}">${label}</span>`;
      }
      function confidenceCell(p){
        const v = (p.confidence!=null) ? Number(p.confidence) : null;
        if(v==null || isNaN(v)) return '-';
        const fixed=v.toFixed(3);
        if(v>=0.8) return `<span class="confidence-high">${fixed}</span>`;
        if(v>=0.6) return `<span class="confidence-medium">${fixed}</span>`;
        return `<span class="confidence-low">${fixed}</span>`;
      }
      function displayName(p){
        if(p.participantPurpose==='internal'){
          if(p.userIds && p.userIds.length){
            const id=p.userIds[0];
            return nameMap[id] || (state.users.find(u=>u.id===id)?.name) || internal[0] || 'Agent';
          }
          return internal[0] || 'Agent';
        }
        return external[0] || 'Customer';
      }

      const convStart = new Date(conversation.conversationStart).getTime();

      let html = '<div class="transcript-summary">';
      html += '<div class="t-summary-grid">';
      html += '<div class="t-kv"><span class="k">Interaction Type:</span><span>' + (getConversationMediaTypes(conversation) || 'Voice') + '</span></div>';
      html += '<div class="t-kv"><span class="k">Conversation Start:</span><span>' + fmt(conversation.conversationStart) + '</span></div>';
      html += '<div class="t-kv"><span class="k">Conversation End:</span><span>' + fmt(conversation.conversationEnd) + '</span></div>';
      html += '<div class="t-kv"><span class="k">Interaction ID:</span><span class="mono">' + conversation.conversationId + '</span></div>';
      html += '<div class="t-kv"><span class="k">Duration:</span><span>' + formatSeconds(calculateDuration(conversation.conversationStart, conversation.conversationEnd)) + '</span></div>';
      html += '<div class="t-kv"><span class="k">Direction:</span><span>' + (getDirection(conversation) || 'Unknown') + '</span></div>';
      html += '</div></div>';

      html += '<table class="transcript-table"><thead><tr>';
      html += '<th>Time (MM:SS)</th>';
      html += '<th>Participant Type</th>';
      html += '<th>Participant</th>';
      html += '<th>Participant Text</th>';
      html += '<th>Sentiment</th>';
      html += '<th>Empathy</th>';
      html += '<th>Confidence</th>';
      html += '</tr></thead><tbody>';

      enriched.forEach(p=>{
        const absolute = p.startTimeMs>1e12;
        const rel = absolute ? (p.startTimeMs - convStart) : p.startTimeMs;
        const timeFormatted = mmss(Math.max(0, rel));
        const participantType = p.participantPurpose==='internal' ? 'Internal' : 'External';
        let row = '<tr>';
        row += '<td class="mono" style="font-weight:bold;">'+timeFormatted+'</td>';
        row += '<td>'+participantType+'</td>';
        row += '<td>'+escapeHtml(displayName(p))+'</td>';
        row += '<td>'+escapeHtml(p.decoratedText)+'</td>';
        row += '<td>'+sentimentCell(p)+'</td>';
        row += '<td>'+empathyCell(p)+'</td>';
        row += '<td>'+confidenceCell(p)+'</td>';
        row += '</tr>';
        html += row;
      });

      html += '</tbody></table>';

      container.innerHTML = html;
    }

    function mapParticipantNames(conv){
      const map={};
      for(const p of (conv.participants||[])){
        if(p.userId){ const u=state.users.find(x=>x.id===p.userId); map[p.participantId||p.userId] = u?u.name:`Agent (${p.userId})`; }
        else if(p.purpose==='customer'){ map[p.participantId||'customer']='Customer'; }
        else if(p.purpose==='acd'){ const qid=getQueueIdFromParticipant(p); map[p.participantId||qid||'acd']=qid?(getQueueName(qid)||'Queue'):'Queue'; }
      } return map;
    }
    function participantsByType(conv){
      const internal=new Set(), external=new Set();
      for(const p of (conv.participants||[])){
        if(p.userId){ const u=state.users.find(x=>x.id===p.userId); internal.add(u?u.name:`Agent (${p.userId})`); }
        else if(p.purpose==='customer'){ external.add(p.participantName||'Customer'); }
      } return {internal:[...internal], external:[...external]};
    }
    function findCommunicationsIdFromDetails(conv){
      for(const p of (conv.participants||[])) for(const s of (p.sessions||[])) if((s.mediaType||'').toLowerCase()==='voice' && s.sessionId) return s.sessionId;
      for(const p of (conv.participants||[])) for(const s of (p.sessions||[])) if(s.sessionId) return s.sessionId;
      for(const p of (conv.participants||[])) for(const s of (p.sessions||[])) if(s.communicationId) return s.communicationId;
      for(const p of (conv.participants||[])) for(const s of (p.sessions||[])) if(s.id) return s.id;
      return null;
    }

    // ===== Fetch conversations =====
    async function fetchConversations(){
      try{
        if(!state.selectedAgent){ setStatus('Please select an agent first', true); return; }
        const from=$('fromDate').value, to=$('toDate').value||from;
        if(!from){ setStatus('Please select a start date', true); return; }
        const today = new Date().toISOString().split('T')[0];
        if(from > today || to > today) { setStatus('Date range cannot be in the future', true); return; }

        setStatus('Fetching conversations‚Ä¶'); setLoading(true); $('resultsSection').style.display='none';

        const auto=$('autoChunk').checked;
        const days = auto? optimalDays(from,to) : (new Date(to)-new Date(from) >= 0 ? (Math.ceil((new Date(to)-new Date(from))/(1000*60*60*24))+1) : 1);
        const dateChunks = auto? chunks(from,to,days) : [{start:from,end:to}];

        $('chunkInfo').innerHTML = auto
          ? 'Large range: <strong>' + fmtDMY(from) + ' to ' + fmtDMY(to) + '</strong><br>Auto-splitting into <strong>' + dateChunks.length + ' chunks</strong> of ' + days + ' days.'
          : 'Processing range: <strong>' + fmtDMY(from) + ' to ' + fmtDMY(to) + '</strong>';

        showProgress();
        state.conversations=[]; state.convIndex={};
        state.allTransfers = []; // Reset transfers
        state.queueTransfers = []; // Reset queue transfers

        for(let i=0;i<dateChunks.length;i++){
          const ch=dateChunks[i]; updateProgress((i/dateChunks.length)*100, i+1, dateChunks.length);
          setStatus('Fetching chunk ' + (i+1) + '/' + dateChunks.length + ': ' + ch.start + ' ‚Üí ' + ch.end);
          try{
            const body = { interval: ch.start + 'T00:00:00/' + ch.end + 'T23:59:59', order:'asc', orderBy:'conversationStart', segmentFilters:[{type:'and',predicates:[{type:'dimension',dimension:'userId',operator:'matches',value: state.selectedAgent.id }]}] };
            const res = await fetch(CONFIG.apiHost + '/api/v2/analytics/conversations/details/query', { method:'POST', headers:{Authorization:'Bearer ' + state.token,'Content-Type':'application/json'}, body:JSON.stringify(body) });
            if(!res.ok){ const t=await res.text().catch(()=> ''); throw new Error('Details error: ' + res.status + ' ' + res.statusText + (t?' - ' + t.slice(0,200):'')); }
            const data = await res.json(); const convs = data.conversations||[];
            for(const c of convs) state.convIndex[c.conversationId]=c;
            state.conversations = state.conversations.concat(convs);
            
            // Extract transfers from conversations
            for(const conv of convs) {
              const transferAnalysis = analyzeTransfers(conv);
              if(transferAnalysis.transfers.length > 0) {
                state.allTransfers = state.allTransfers.concat(
                  transferAnalysis.transfers.map(t => ({
                    ...t,
                    conversationId: conv.conversationId,
                    conversationStart: conv.conversationStart
                  }))
                );
                
                // Extract queue transfers (Queue ‚Üí Queue and Agent‚ÜíQueue/Queue‚ÜíAgent with queue context)
                const queueTransfers = transferAnalysis.transfers.filter(t => 
                  t.type === 'Queue ‚Üí Queue' || 
                  (t.fromQueueId && t.toQueueId) // Both have queue context
                );
                if (queueTransfers.length > 0) {
                  state.queueTransfers = state.queueTransfers.concat(
                    queueTransfers.map(t => ({
                      ...t,
                      conversationId: conv.conversationId,
                      conversationStart: conv.conversationStart,
                      // For matrix, use queue IDs when available
                      matrixFromId: t.fromQueueId || t.fromId,
                      matrixToId: t.toQueueId || t.toId
                    }))
                  );
                }
              }
            }
          }catch(e){ console.error(e); setStatus('Warning: failed chunk ' + (i+1) + ', continuing‚Ä¶', true); }
          if(i<dateChunks.length-1) await new Promise(r=>setTimeout(r,400));
        }

        await warmQueueCache(state.conversations);

        updateProgress(100, dateChunks.length, dateChunks.length);
        renderResults(state.conversations, from, to);
        renderTransferReport(); // Render the transfer report
        renderQueueTransferMatrix(); // Render the queue transfer matrix
        setStatus('Found ' + state.conversations.length + ' conversations for the selected period');
        setLoading(false); hideProgress();
      }catch(e){ setStatus('Error fetching conversations: ' + e.message, true); setLoading(false); hideProgress(); }
    }

    function renderResults(conversations, from, to){
      const results=$('results');
      $('dateRange').textContent = fmtDMY(from) + ' to ' + fmtDMY(to||from);
      $('selectedAgent').textContent = state.selectedAgent?.name||'-';
      $('totalConversations').textContent = conversations.length;

      if(!conversations.length){
        results.innerHTML = '<div class="muted" style="text-align:center;padding:40px"><div style="font-size:48px;margin-bottom:12px">üì≠</div><div>No conversations found for ' + (state.selectedAgent?.name||'the selected agent') + '.</div></div>';
        $('resultsSection').style.display='block'; return;
      }

      results.innerHTML = conversations.map(function(conv){
        const participants = conv.participants ? conv.participants.length : 0;
        const media = getConversationMediaTypes(conv);
        const dir = getDirection(conv);
        return '<details><summary><strong>' + conv.conversationId + '</strong> - ' + fmt(conv.conversationStart) + '<span class="muted" style="margin-left:8px;font-size:.9em">(' + participants + ' participants) ‚Ä¢ Media: ' + media + ' ‚Ä¢ Dir: ' + dir + '</span></summary>' + renderConversationDetails(conv) + '</details>';
      }).join('');

      $('resultsSection').style.display='block';
    }

    function renderConversationDetails(conv){
      const mediaType = getMediaType(conv);
      const direction = getDirection(conv);
      const ani = getANI(conv);
      const totalDur = calculateDuration(conv.conversationStart, conv.conversationEnd);
      const transfers = analyzeTransfers(conv);

      let html = '<div class="conversation-header">';
      html += '<div class="info-grid">';
      html += '<div class="info-item"><span class="info-label">Media Type:</span><span class="info-value">' + mediaType + '</span></div>';
      html += '<div class="info-item"><span class="info-label">Customer Number:</span><span class="info-value">' + ani + '</span></div>';
      html += '<div class="info-item"><span class="info-label">Interaction Direction:</span><span class="info-value">' + direction + '</span></div>';
      html += '<div class="info-item"><span class="info-label">Conversation Start:</span><span class="info-value">' + fmt(conv.conversationStart) + '</span></div>';
      html += '<div class="info-item"><span class="info-label">Conversation End:</span><span class="info-value">' + fmt(conv.conversationEnd) + '</span></div>';
      html += '<div class="info-item"><span class="info-label">Duration:</span><span class="info-value">' + formatSeconds(totalDur) + '</span></div>';
      html += '<div class="info-item"><span class="info-label">Transfers (Agent‚ÜíQueue/Agent):</span><span class="info-value"><span class="transfer-count">' + transfers.totalTransfers + '</span></span></div>';
      html += '</div>';

      html += '<div class="transcript-actions" style="display:flex;gap:8px;align-items:center;margin-top:8px">';
      html += '<button id="btn-transcript-' + conv.conversationId + '" onclick="getTranscriptForConversation(\'' + conv.conversationId + '\')">Get Transcript</button>';
      html += '<span id="transcript-status-' + conv.conversationId + '" class="muted"></span>';
      html += '</div>';
      html += '<div id="transcript-' + conv.conversationId + '" style="margin-top:10px;"></div>';
      html += '</div>';

      html += '<h3 style="margin:14px 0 6px;">Customer Journey Timeline</h3>';
      html += '<div class="journey-timeline">';
      html += renderJourneyTimeline(conv, transfers);
      html += '</div>';

      html += '<details><summary>Raw Conversation Data</summary><pre>' + JSON.stringify(conv, null, 2) + '</pre></details>';
      
      return html;
    }

    function renderJourneyTimeline(conv, transferInfo){
      if(!conv.participants || !conv.participants.length) return '<p class="muted">No participant data available</p>';
      const sorted = [...conv.participants].map(function(p){return {p:p,start:getStepStart(p)};})
        .sort(function(a,b){return (a.start?.getTime()??Infinity)-(b.start?.getTime()??Infinity);})
        .map(function(x){return x.p;});

      return sorted.map(function(p,idx){
        const purpose = p.purpose||'unknown';
        const start = getStepStart(p);
        const nextStart = idx<sorted.length-1 ? getStepStart(sorted[idx+1]) : null;
        const queueId = getQueueIdFromParticipant(p);
        const queueName = queueId ? (getQueueName(queueId)||queueId) : null;
        const name = purpose==='acd' ? (queueName?'Queue: ' + queueName:'ACD Queue') : getParticipantName(p);

        let durMs = 0;
        if(p.userId) durMs = getAgentWindow(p).durationMs||0;
        else if(start && nextStart) durMs = Math.max(0, nextStart - start);

        const alertMs = p.userId ? getAlertMsForAgent(p) : null;
        const alertTime = p.userId ? (Math.floor((alertMs||0)/1000) + 's') : 'N/A';

        const transfer = transferInfo.transfers.find(function(t){return t.step===idx;});

        let stepHtml = '<div class="journey-step">';
        stepHtml += '<div class="step-header">Step ' + (idx+1) + ': ' + badge(purpose, name) + (transfer?'<span style="color:#dc2626;margin-left:8px">üîÑ TRANSFERRED</span>':'') + '</div>';
        stepHtml += '<div class="step-details">';
        if(transfer){
          stepHtml += '<div class="transfer-info"><strong>Transfer:</strong> ' + transfer.type + '<br>From: ' + transfer.from + ' ‚Üí To: ' + transfer.to + '<br>Time: ' + fmt(transfer.time) + '</div>';
        }
        stepHtml += '<div class="info-grid">';
        stepHtml += '<div class="info-item"><span class="info-label">Participant Type:</span><span class="info-value">' + getParticipantType(p) + '</span></div>';
        stepHtml += '<div class="info-item"><span class="info-label">Start Time:</span><span class="info-value">' + fmt(start) + '</span></div>';
        if(queueName) stepHtml += '<div class="info-item"><span class="info-label">Queue:</span><span class="info-value">' + queueName + '</span></div>';
        stepHtml += '<div class="info-item"><span class="info-label">Duration:</span><span class="info-value">' + formatSeconds(durMs) + '</span></div>';
        stepHtml += '<div class="info-item"><span class="info-label">Alert Time:</span><span class="info-value">' + alertTime + '</span></div>';
        stepHtml += '<div class="info-item"><span class="info-label">Purpose:</span><span class="info-value">' + purpose + '</span></div>';
        stepHtml += '<div class="info-item"><span class="info-label">Sessions:</span><span class="info-value">' + ((p.sessions&&p.sessions.length)||1) + '</span></div>';
        stepHtml += '</div></div></div>';
        return stepHtml;
      }).join('');
    }

    // ===== Transfer Reporting =====
    function renderTransferReport() {
      const statsContainer = $('transferStats');
      const tableBody = $('transferTableBody');
      const noTransfersMessage = $('noTransfersMessage');
      
      if (state.allTransfers.length === 0) {
        statsContainer.innerHTML = '';
        tableBody.innerHTML = '';
        noTransfersMessage.style.display = 'block';
        return;
      }
      
      noTransfersMessage.style.display = 'none';
      
      // Calculate statistics
      const totalTransfers = state.allTransfers.length;
      const agentToAgent = state.allTransfers.filter(t => t.type === 'Agent ‚Üí Agent').length;
      const queueToQueue = state.allTransfers.filter(t => t.type === 'Queue ‚Üí Queue').length;
      
      // Render statistics
      statsContainer.innerHTML = `
        <div class="transfer-stat-card">
          <div class="transfer-stat-number">${totalTransfers}</div>
          <div class="transfer-stat-label">Total Transfers</div>
        </div>
        <div class="transfer-stat-card">
          <div class="transfer-stat-number">${agentToAgent}</div>
          <div class="transfer-stat-label">Agent ‚Üí Agent</div>
        </div>
        <div class="transfer-stat-card">
          <div class="transfer-stat-number">${queueToQueue}</div>
          <div class="transfer-stat-label">Queue ‚Üí Queue</div>
        </div>
      `;
      
      // Apply filters
      const filterType = $('transferFilter').value;
      const searchTerm = $('transferSearch').value.toLowerCase();
      
      let filteredTransfers = state.allTransfers;
      
      if (filterType !== 'all') {
        filteredTransfers = filteredTransfers.filter(t => {
          if (filterType === 'agent-to-agent') return t.type === 'Agent ‚Üí Agent';
          if (filterType === 'queue-to-queue') return t.type === 'Queue ‚Üí Queue';
          return true;
        });
      }
      
      if (searchTerm) {
        filteredTransfers = filteredTransfers.filter(t => {
          const fromName = getTransferParticipantName(t.fromId, t.from);
          const toName = getTransferParticipantName(t.toId, t.to);
          return t.conversationId.toLowerCase().includes(searchTerm) || 
                 fromName.toLowerCase().includes(searchTerm) || 
                 toName.toLowerCase().includes(searchTerm);
        });
      }
      
      // Render table
      if (filteredTransfers.length === 0) {
        tableBody.innerHTML = '<tr><td colspan="6" style="text-align:center;padding:20px">No transfers match the selected filters</td></tr>';
        return;
      }
      
      tableBody.innerHTML = filteredTransfers.map(transfer => {
        const fromName = getTransferParticipantName(transfer.fromId, transfer.from);
        const toName = getTransferParticipantName(transfer.toId, transfer.to);
        
        return `
          <tr>
            <td class="mono">${transfer.conversationId}</td>
            <td>${fromName}</td>
            <td>${toName}</td>
            <td>${transfer.type}</td>
            <td>${fmt(transfer.time)}</td>
            <td>${formatSeconds(transfer.duration)}</td>
          </tr>
        `;
      }).join('');
    }
    
    function getTransferParticipantName(id, type) {
      if (type === 'Agent') {
        const user = state.users.find(u => u.id === id);
        return user ? user.name : `Agent (${id})`;
      } else if (type === 'Queue') {
        return getQueueName(id) || `Queue (${id})`;
      }
      return type;
    }
    
    // ===== Queue Transfer Matrix =====
    function renderQueueTransferMatrix() {
      const statsContainer = $('matrixStats');
      const matrixContainer = $('matrixContainer');
      const noMatrixDataMessage = $('noMatrixDataMessage');
      const selectedAgentId = $('matrixAgentSelect').value;
      
      // Filter transfers based on agent selection
      let transfersToShow = state.queueTransfers;
      
      if (selectedAgentId !== 'all') {
        // Filter to only include conversations that involved the selected agent
        const agentConversations = state.conversations.filter(conv => 
          conv.participants && conv.participants.some(p => p.userId === selectedAgentId)
        );
        const agentConversationIds = new Set(agentConversations.map(c => c.conversationId));
        transfersToShow = transfersToShow.filter(t => agentConversationIds.has(t.conversationId));
      }
      
      console.log('Queue transfers for matrix:', transfersToShow);
      
      if (transfersToShow.length === 0) {
        statsContainer.innerHTML = '';
        matrixContainer.innerHTML = '';
        noMatrixDataMessage.style.display = 'block';
        return;
      }
      
      noMatrixDataMessage.style.display = 'none';
      
      // Calculate matrix statistics
      const totalQueueTransfers = transfersToShow.length;
      const uniqueFromQueues = [...new Set(transfersToShow.map(t => t.matrixFromId))].length;
      const uniqueToQueues = [...new Set(transfersToShow.map(t => t.matrixToId))].length;
      
      // Render statistics
      statsContainer.innerHTML = `
        <div class="transfer-stat-card">
          <div class="transfer-stat-number">${totalQueueTransfers}</div>
          <div class="transfer-stat-label">Queue Transfers</div>
        </div>
        <div class="transfer-stat-card">
          <div class="transfer-stat-number">${uniqueFromQueues}</div>
          <div class="transfer-stat-label">Source Queues</div>
        </div>
        <div class="transfer-stat-card">
          <div class="transfer-stat-number">${uniqueToQueues}</div>
          <div class="transfer-stat-label">Target Queues</div>
        </div>
      `;
      
      // Build the transfer matrix
      const fromQueues = [...new Set(transfersToShow.map(t => t.matrixFromId))];
      const toQueues = [...new Set(transfersToShow.map(t => t.matrixToId))];
      
      // Get all unique queue names for rows and columns
      const allQueues = [...new Set([...fromQueues, ...toQueues])];
      
      // Create a matrix to count transfers between queues
      const matrix = {};
      allQueues.forEach(fromQueue => {
        matrix[fromQueue] = {};
        allQueues.forEach(toQueue => {
          matrix[fromQueue][toQueue] = 0;
        });
      });
      
      // Count transfers
      transfersToShow.forEach(transfer => {
        if (matrix[transfer.matrixFromId] && matrix[transfer.matrixFromId][transfer.matrixToId] !== undefined) {
          matrix[transfer.matrixFromId][transfer.matrixToId]++;
        }
      });
      
      // Generate the matrix table HTML
      let matrixHtml = '<table class="matrix-table">';
      
      // Header row with TO queues
      matrixHtml += '<thead><tr>';
      matrixHtml += '<th class="from-header">FROM / TO</th>';
      allQueues.forEach(queueId => {
        const queueName = getQueueName(queueId) || `Queue ${queueId}`;
        matrixHtml += `<th class="to-header">${queueName}</th>`;
      });
      matrixHtml += '</tr></thead>';
      
      // Data rows
      matrixHtml += '<tbody>';
      allQueues.forEach(fromQueueId => {
        const fromQueueName = getQueueName(fromQueueId) || `Queue ${fromQueueId}`;
        matrixHtml += `<tr><td class="from-label">${fromQueueName}</td>`;
        
        allQueues.forEach(toQueueId => {
          const count = matrix[fromQueueId][toQueueId];
          let cellClass = '';
          if (count > 0) {
            if (count >= 10) cellClass = 'matrix-high';
            else if (count >= 5) cellClass = 'matrix-medium';
            else cellClass = 'matrix-low';
          }
          
          matrixHtml += `<td class="${cellClass}"><span class="matrix-count">${count}</span></td>`;
        });
        
        matrixHtml += '</tr>';
      });
      matrixHtml += '</tbody></table>';
      
      matrixContainer.innerHTML = matrixHtml;
    }
    
    // Set up transfer report filters
    function setupTransferFilters() {
      $('transferFilter').addEventListener('change', renderTransferReport);
      $('transferSearch').addEventListener('input', renderTransferReport);
      $('matrixAgentSelect').addEventListener('change', renderQueueTransferMatrix);
    }

    // ===== Events & Init =====
    $('fetchBtn').addEventListener('click', fetchConversations);
    (function init(){
      const today=new Date(); const weekAgo=new Date(); weekAgo.setDate(today.getDate()-7);
      $('fromDate').value = weekAgo.toISOString().slice(0,10);
      $('toDate').value = today.toISOString().slice(0,10);
      initAuth();
      setupTransferFilters();
    })();
  </script>
</body>
</html>
