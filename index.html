<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Genesys Conversation Explorer</title>
  <style>
    :root{
      --primary-color:#63AB8F; --secondary-color:#4A8C7D; --border-color:#DEE2E6;
      --light-bg:#F8F9FA; --card-bg:#FFFFFF; --text-color:#2C3E50; --text-light:#6C757D;
      --pill:#e9f6f0;
    }
    body{font-family:'Segoe UI',Arial,sans-serif;margin:20px;padding:20px;max-width:1200px;background:var(--light-bg);color:var(--text-color)}
    #logo-container{text-align:center;margin-bottom:20px} #logo{width:300px}
    h1{margin:0 0 16px}
    .card{background:var(--card-bg);border:1px solid var(--border-color);border-radius:12px;padding:24px;margin-top:16px;box-shadow:0 1px 3px rgba(0,0,0,.1)}
    label{display:block;font-weight:600;margin-bottom:6px}
    select,input,button{padding:10px;border:1px solid var(--border-color);border-radius:6px;background:var(--card-bg);font-size:14px}
    button{background:var(--primary-color);color:#fff;font-weight:600;cursor:pointer;transition:background .2s}
    button:hover{background:var(--secondary-color)} button:disabled{background:var(--text-light);cursor:not-allowed}
    .controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:20px 24px;align-items:start}
    .inline{display:grid;grid-template-columns:1fr auto 1fr;gap:16px;align-items:center} .inline span{color:var(--text-light)}
    .full-width-btn{width:100%;padding:14px 18px;font-size:16px;margin-top:12px}
    .muted{color:var(--text-light)} .mono{font-family:ui-monospace,Consolas,Menlo,monospace}
    .user-info,.conversation-header,.transcript-summary{background:transparent;border:2px solid var(--primary-color);border-radius:10px;padding:16px;margin:12px 0}
    details{background:var(--light-bg);border:1px solid var(--border-color);border-radius:8px;padding:16px;margin:12px 0}
    details>summary{cursor:pointer;font-weight:600}
    pre{background:#1f2937;color:#f3f4f6;padding:16px;border-radius:6px;overflow:auto;font-size:12px}
    .stats{display:flex;gap:16px;margin:16px 0}
    .stat-card{flex:1;border:1px solid var(--border-color);border-radius:8px;padding:16px;text-align:center;background:var(--card-bg)}
    .stat-number{font-size:22px;color:#63AB8F;font-weight:700}
    .journey-timeline{margin:20px 0 8px;padding-left:20px;border-left:3px solid var(--primary-color)}
    .journey-step{margin-bottom:18px;position:relative}
    .journey-step:before{content:'';position:absolute;left:-26px;top:0;width:16px;height:16px;border-radius:50%;background:var(--primary-color)}
    .step-header{font-weight:700;color:var(--secondary-color);margin-bottom:8px}
    .step-details{background:var(--card-bg);border:1px solid var(--border-color);border-radius:6px;padding:12px}
    .info-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:12px}
    .info-item{display:flex;justify-content:space-between;border-bottom:1px solid var(--border-color);padding:6px 0}
    .info-label{font-weight:600;min-width:150px}
    .participant-badge{display:inline-block;padding:4px 8px;border-radius:4px;font-size:12px;font-weight:600;margin:2px;border:1px solid var(--border-color);background:#fff}
    .badge-customer{border-color:#a7e3c6;color:#1f7255}
    .badge-agent{background:#dbeafe;color:#1e40af}
    .badge-queue{background:#fde7ff;color:#7c3aed}
    .transfer-info{background:#fff7ed;border:1px solid var(--border-color);border-radius:6px;padding:8px;margin:8px 0}
    .transfer-count{background:#fee2e2;color:#b91c1c;padding:2px 8px;border-radius:6px;font-weight:700}
    .progress-bar{width:100%;height:8px;background:var(--border-color);border-radius:4px;overflow:hidden;margin:10px 0}
    .progress-fill{height:100%;background:var(--primary-color);transition:width .3s}
    .t-summary-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:10px 16px}
    .t-kv{display:flex;gap:10px;justify-content:space-between}.t-kv .k{font-weight:700}
    .pill{display:inline-block;background:var(--pill);border:1px solid var(--border-color);border-radius:999px;padding:2px 8px;font-size:12px;margin-right:6px}
    .transcript-table{width:100%;border-collapse:collapse;margin-top:10px}
    .transcript-table th,.transcript-table td{border-bottom:1px solid var(--border-color);padding:8px 10px;vertical-align:top}
    .transcript-table th{background:var(--primary-color);color:#fff;text-align:left}
    .sentiment-positive{color:#16a34a;font-weight:700}
    .sentiment-negative{color:#dc2626;font-weight:700}
    .sentiment-neutral{color:#f59e0b;font-weight:700}
    .empathy-positive{color:#16a34a;font-weight:700}
    .confidence-high{color:#16a34a;font-weight:700}
    .confidence-medium{color:#f59e0b;font-weight:700}
    .confidence-low{color:#dc2626;font-weight:700}
    .loading{opacity:.6;pointer-events:none}
    .future-date{color:#ccc;cursor:not-allowed}
  </style>
</head>
<body>
  <div id="logo-container">
    <img id="logo" src="https://raw.githubusercontent.com/gmcglynn88/ExternalWorkCreation/main/Consultinglogo.png" alt="Company Logo">
  </div>
  <h1>Conversation Explorer</h1>
  <button id="signinBtn" style="display:none;margin-bottom:12px;">Sign in to Genesys Cloud</button>

  <div id="authStatus" class="card" style="display:none;">
    <div style="text-align:center;padding:20px;">
      <div style="font-size:18px;color:var(--secondary-color);margin-bottom:8px;">üîê Authenticating‚Ä¶</div>
      <div class="muted">Connecting to Genesys Cloud</div>
    </div>
  </div>

  <div id="mainContent" style="display:none;">
    <div class="card">
      <h2 style="margin:0 0 12px;">Select Agent & Date Range</h2>
      <div class="controls">
        <div>
          <label for="agentSelect">Select Agent</label>
          <select id="agentSelect"><option>Loading users‚Ä¶</option></select>
          <input id="agentFilter" type="text" placeholder="Filter users by name" style="margin-top:8px"/>
          <div class="user-info" id="selectedAgentInfo" style="display:none;">
            <strong>Selected Agent:</strong> <span id="selectedAgentName">None</span>
          </div>
        </div>
        <div>
          <label>Date Range</label>
          <div class="inline">
            <input id="fromDate" type="date"/>
            <span>to</span>
            <input id="toDate" type="date"/>
          </div>
          <label style="display:flex;align-items:center;gap:8px;margin-top:8px;">
            <input id="autoChunk" type="checkbox" checked/> Auto-split large date ranges (recommended)
          </label>
        </div>
      </div>
      <button id="fetchBtn" class="full-width-btn">Fetch Conversations</button>
    </div>

    <div id="statusMessage" class="muted" style="margin-top:10px;"></div>
    <div id="errorMessage" style="color:#dc2626;margin-top:6px;"></div>

    <div id="progressSection" style="display:none;">
      <div class="card">
        <h3 style="margin:0 0 8px;">Fetching Conversations</h3>
        <div class="muted" id="chunkInfo">Processing date range in smaller chunks‚Ä¶</div>
        <div class="progress-bar"><div class="progress-fill" id="progressFill" style="width:0%"></div></div>
        <div style="display:flex;justify-content:space-between;font-size:14px" class="muted">
          <span id="progressText">0%</span><span id="chunkText">Chunk 0/0</span>
        </div>
      </div>
    </div>

    <div id="resultsSection" style="display:none;">
      <div class="card">
        <h2 style="margin:0 0 12px;">Conversation Results</h2>
        <div class="stats">
          <div class="stat-card"><div class="stat-number" id="totalConversations">0</div><div class="stat-label">Total Conversations</div></div>
          <div class="stat-card"><div class="stat-number" id="dateRange">-</div><div class="stat-label">Date Range</div></div>
          <div class="stat-card"><div class="stat-number" id="selectedAgent">-</div><div class="stat-label">Selected Agent</div></div>
        </div>
        <div id="results"></div>
      </div>
    </div>
  </div>

  <script>
    // ===== Config (Ireland) =====
    const CONFIG = {
      clientId: 'd4529142-7340-4cd8-a9f9-f3a4d25670df',
      redirectUri: 'https://gmcglynn88.github.io/ConversationExplorer/',
      loginHost: 'https://login.mypurecloud.ie',
      apiHost: 'https://api.mypurecloud.ie'
    };

    // ===== State =====
    const state = { token:null, users:[], queues:{}, conversations:[], selectedAgent:null, convIndex:{} };

    // ===== Utils =====
    const $ = id => document.getElementById(id);
    const setStatus = (msg,err=false)=>{ $('statusMessage').textContent = err?'':(msg||''); $('errorMessage').textContent = err?(msg||''):''; };
    const fmt = d => { if(!d) return 'N/A'; try{return new Date(d).toLocaleString()}catch{return 'N/A'} };
    const fmtDMY = s => { if(!s||s.length<10) return s||''; const [y,m,d]=s.slice(0,10).split('-'); return `${d}-${m}-${y}`; };
    const formatSeconds = ms => { if(!ms) return '0s'; const s=Math.floor(ms/1000), m=Math.floor(s/60), h=Math.floor(m/60); if(h) return `${h}h ${m%60}m ${s%60}s`; if(m) return `${m}m ${s%60}s`; return `${s}s`; };
    const mmss = ms => { const totalSeconds = Math.max(0, Math.floor((+ms||0)/1000)); const minutes = Math.floor(totalSeconds / 60); const seconds = totalSeconds % 60; return String(minutes).padStart(2, '0') + ':' + String(seconds).padStart(2, '0'); };
    const calculateDuration = (a,b)=>{ if(!a||!b) return 0; return new Date(b)-new Date(a); };

    function showMain(){ $('authStatus').style.display='none'; $('mainContent').style.display='block'; }
    function setLoading(v){ $('mainContent').classList.toggle('loading', !!v); }
    function updateProgress(p,cur,total){ $('progressFill').style.width = `${p}%`; $('progressText').textContent = `${Math.round(p)}%`; $('chunkText').textContent = `Chunk ${cur}/${total}`; }
    function showProgress(){ $('progressSection').style.display='block'; $('resultsSection').style.display='none'; }
    function hideProgress(){ $('progressSection').style.display='none'; }

    // ===== Date Range Limiting =====
    function setupDateLimits() {
      const today = new Date().toISOString().split('T')[0];
      $('fromDate').max = today; $('toDate').max = today;
      $('fromDate').addEventListener('change', function() {
        if (this.value > today) this.value = today;
        if ($('toDate').value && this.value > $('toDate').value) $('toDate').value = this.value;
      });
      $('toDate').addEventListener('change', function() {
        if (this.value > today) this.value = today;
        if ($('fromDate').value && this.value < $('fromDate').value) $('fromDate').value = this.value;
      });
    }

    // ===== Auth (Implicit) =====
    function parseTokenFromHash(){
      const params = new URLSearchParams(location.hash.replace(/^#/, ''));
      return { token: params.get('access_token'), error: params.get('error'), errorDescription: params.get('error_description') };
    }
    function authUrl(){
      return `${CONFIG.loginHost}/oauth/authorize?client_id=${encodeURIComponent(CONFIG.clientId)}&response_type=token&redirect_uri=${encodeURIComponent(CONFIG.redirectUri)}`;
    }
    function initAuth(){
      const {token} = parseTokenFromHash();
      if(location.hash) history.replaceState(null,'',location.pathname);
      if(token){
        state.token = token; showMain(); setupDateLimits(); fetchAllUsers();
      } else {
        $('signinBtn').style.display = 'inline-block';
        $('signinBtn').onclick = () => location.assign(authUrl());
        $('authStatus').style.display = 'none';
      }
    }

    // ===== API helper =====
    async function api(path){
      if(!state.token) throw new Error('Not authenticated');
      const res = await fetch(`${CONFIG.apiHost}${path}`, { headers:{Authorization:`Bearer ${state.token}`} });
      if(res.status===401||res.status===403) throw new Error(`Authentication error (${res.status}). Please refresh.`);
      if(!res.ok){ const t = await res.text().catch(()=> ''); throw new Error(`API Error: ${res.status} ${res.statusText}${t?` - ${t.slice(0,200)}`:''}`); }
      return res.json();
    }

    // ===== Users =====
    async function fetchAllUsers(){
      try{
        setStatus('Loading users‚Ä¶'); setLoading(true);
        let all=[], page=1, size=100;
        while(true){
          const data = await api(`/api/v2/users?pageSize=${size}&pageNumber=${page}`);
          const ents = data?.entities||[]; all = all.concat(ents);
          if(!data?.nextUri || ents.length<size) break; page++;
        }
        state.users = all.map(u=>({id:u.id,name:u.name||'',email:u.email||''})).sort((a,b)=>a.name.localeCompare(b.name));
        populateUserSelect(state.users);
        setStatus(`Loaded ${state.users.length} users`); setLoading(false);
      }catch(e){ setStatus(`Failed to load users: ${e.message}`, true); setLoading(false); $('agentSelect').innerHTML='<option>Failed to load users</option>'; }
    }
    function populateUserSelect(users){
      const sel=$('agentSelect');
      sel.innerHTML = '<option value="">Select an agent‚Ä¶</option>' + users.map(u=>`<option value="${u.id}">${u.name||'(Unnamed)'}</option>`).join('');
      sel.onchange=()=>{ const u = users.find(x=>x.id===sel.value); state.selectedAgent=u||null; if(u){ $('selectedAgentName').textContent=u.name||'(Unnamed)'; $('selectedAgentInfo').style.display='block'; } else { $('selectedAgentInfo').style.display='none'; } };
    }
    $('agentFilter').addEventListener('input', function(){
      const q = this.value.trim().toLowerCase();
      populateUserSelect(q ? state.users.filter(u=>(u.name||'').toLowerCase().includes(q)) : state.users);
    });

    // ===== Chunking =====
    function chunks(start,end,days){
      const out=[]; const s=new Date(start), e=new Date(end); let cur=new Date(s);
      while(cur<=e){ let ce=new Date(cur); ce.setDate(ce.getDate()+days-1); if(ce>e) ce=new Date(e);
        out.push({start:cur.toISOString().slice(0,10), end:ce.toISOString().slice(0,10)}); cur.setDate(cur.getDate()+days);
      } return out;
    }
    function optimalDays(start,end){
      const s=new Date(start), e=new Date(end), total=Math.ceil((e-s)/(1000*60*60*24))+1;
      if(total<=7) return 7; if(total<=30) return 7; if(total<=90) return 5; if(total<=180) return 3; return 2;
    }

    // ===== Queue helpers =====
    function getQueueIdFromParticipant(p){ if(p.queueId) return p.queueId; for(const s of (p.sessions||[])) if(s.queueId) return s.queueId; return null; }
    function getQueueName(id){ return state.queues[id]||null; }
    async function fetchQueueName(id){ if(!id||state.queues[id]) return; try{ const q=await api(`/api/v2/routing/queues/${id}`); state.queues[id]=q?.name||id; }catch{ state.queues[id]=id; } }
    async function warmQueueCache(convs){
      const set=new Set(); for(const c of convs) for(const p of (c.participants||[])){ const id=getQueueIdFromParticipant(p); if(id) set.add(id); }
      await Promise.all([...set].filter(id=>!state.queues[id]).map(fetchQueueName));
    }

    // ===== Conversation helpers =====
    function firstSession(c){ for(const p of (c.participants||[])) for(const s of (p.sessions||[])) return s; return null; }
    function getMediaType(c){ return (firstSession(c)?.mediaType)||'Unknown'; }
    function getDirection(c){ return firstSession(c)?.direction || c.originatingDirection || 'Unknown'; }
    function getConversationMediaTypes(c){ const t=new Set(); for(const p of (c.participants||[])) for(const s of (p.sessions||[])) if(s.mediaType) t.add(s.mediaType); return [...t].join(', ')||getMediaType(c); }
    function getANI(c){
      for(const p of (c.participants||[])) for(const s of (p.sessions||[])){
        if((s.mediaType||'').toLowerCase()!=='voice') continue;
        const dir=(s.direction||c.originatingDirection||'').toLowerCase();
        if(dir==='inbound') return s.ani||s.addressFrom||s.otherAddress||s.remote||'Unknown';
      }
      const s=firstSession(c); return s?.ani||s?.addressFrom||s?.otherAddress||s?.remote||'Unknown';
    }
    function getStepStart(p){
      let t=[]; for(const s of (p.sessions||[])){
        if(s.startTime){ const v=+new Date(s.startTime); if(!isNaN(v)) t.push(v); }
        for(const seg of (s.segments||[])){
          if(seg.segmentStart){ const v=+new Date(seg.segmentStart); if(!isNaN(v)) t.push(v); }
          for(const ev of (seg.events||[])) if(ev.eventTime){ const v=+new Date(ev.eventTime); if(!isNaN(v)) t.push(v); }
        }
      }
      return t.length? new Date(Math.min(...t)) : null;
    }
    function getAgentWindow(p){
      let s=[],e=[]; for(const ss of (p.sessions||[])){
        for(const seg of (ss.segments||[])){
          if(seg.segmentStart){ const v=+new Date(seg.segmentStart); if(!isNaN(v)) s.push(v); }
          if(seg.segmentEnd){ const v=+new Date(seg.segmentEnd); if(!isNaN(v)) e.push(v); }
        }
      }
      if(!s.length||!e.length) return {durationMs:0}; return {durationMs: Math.max(...e)-Math.min(...s)};
    }
    function getAlertMsForAgent(p){
      if(!p?.userId) return 0; let total=0; const add=v=>{ if(v==null||isNaN(v))return; const ms=(v>120)?v:v*1000; total+=ms; };
      for(const s of (p.sessions||[])){
        if(Array.isArray(s.metrics)) for(const m of s.metrics) if(m?.name==='tAlert') add(m.value??m.durationMs);
        for(const seg of (s.segments||[])){
          if(Array.isArray(seg.metrics)) for(const m of seg.metrics) if(m?.name==='tAlert') add(m.value??m.durationMs);
          for(const ev of (seg.events||[])) if(Array.isArray(ev.metrics)) for(const m of ev.metrics) if(m?.name==='tAlert') add(m.value??m.durationMs);
        }
      }
      return total;
    }
    function buildLegs(c){
      const legs=[]; for(const p of (c.participants||[])){
        const when=getStepStart(p)?.getTime()??Infinity; legs.push({when,purpose:p.purpose,userId:p.userId||null,queueId:getQueueIdFromParticipant(p)||null});
      }
      legs.sort((a,b)=>a.when-b.when); return legs.filter(l=>Number.isFinite(l.when));
    }
    function analyzeTransfers(c){
      const legs=buildLegs(c), transfers=[]; let count=0;
      for(let i=1;i<legs.length;i++){ const prev=legs[i-1], cur=legs[i];
        const a2a = prev.userId && cur.userId && prev.userId!==cur.userId;
        const a2q = prev.userId && cur.queueId && !cur.userId;
        if(a2a||a2q){ count++; transfers.push({step:i,from: prev.userId?'Agent':(prev.queueId?'Queue':(prev.purpose||'Unknown')), to: cur.userId?'Agent':(cur.queueId?'Queue':(cur.purpose||'Unknown')), time:new Date(cur.when).toISOString(), type:a2a?'Agent ‚Üí Agent':'Agent ‚Üí Queue'}); }
      }
      return {totalTransfers:count, transfers};
    }
    function getParticipantName(p){
      if(p.purpose==='customer') return 'Customer';
      if(p.userId){ const u=state.users.find(x=>x.id===p.userId); return u?u.name:`Agent (${p.userId})`; }
      if(p.purpose==='acd') return 'ACD Queue';
      if(p.purpose==='ivr') return 'IVR System';
      if(p.purpose==='external') return 'External System';
      return p.purpose||'Unknown';
    }
    function getParticipantType(p){
      if(p.purpose==='customer') return 'Customer';
      if(p.userId) return 'Agent';
      if(p.purpose==='acd') return 'Queue';
      if(p.purpose==='ivr') return 'IVR System';
      if(p.purpose==='external') return 'External';
      return p.purpose||'Unknown';
    }
    function badge(purpose,name){
      const cls = {'customer':'badge-customer','user':'badge-agent','acd':'badge-queue','ivr':'badge-ivr','external':'badge-system','queue':'badge-queue'}[purpose]||'badge-system';
      return '<span class="participant-badge ' + cls + '">' + name + '</span>';
    }

    // ===== Transcript helpers (robust + numeric‚Üílabel) =====
    function normaliseRole(v){
      const s=(v||'').toString().toLowerCase();
      if(['internal','agent','user'].includes(s)) return 'internal';
      if(['external','customer','participant','caller','callee'].includes(s)) return 'external';
      return s||'external';
    }
    function labelToScore(v){
      if(v==null) return null;
      if(typeof v==='number') return v;
      const s=v.toString().toUpperCase();
      if(s.includes('POS')) return 0.6;
      if(s.includes('NEG')) return -0.6;
      if(s.includes('NEU')) return 0;
      const n=parseFloat(v); return isNaN(n)?null:n;
    }
    function coerceMs(x){
      const n=Number(x); if(!isNaN(n)) return n;
      const d=+new Date(x); return isNaN(d)?null:d;
    }

    // üëâ merge analytics from ALL transcripts (and top-level if present)
    function extractSignals(parsed){
      const out=[]; const buckets=[];
      if(parsed?.analytics) buckets.push(parsed.analytics);
      if(Array.isArray(parsed?.transcripts)){
        for(const tr of parsed.transcripts){ if(tr?.analytics) buckets.push(tr.analytics); }
      }
      for(const a of buckets){
        if(!a) continue;
        // Sentiment
        if(Array.isArray(a.sentiment)){
          for(const s of a.sentiment){
            out.push({
              kind:'sentiment',
              role:normaliseRole(s.participant||s.participantPurpose),
              startTimeMs:coerceMs(s.startTimeMs),
              endTimeMs:(s.duration?.milliseconds!=null)?(coerceMs(s.startTimeMs)+Number(s.duration.milliseconds)):coerceMs(s.endTimeMs),
              value:labelToScore(s.sentiment??s.score??s.value??s.level)
            });
          }
        }
        // Empathy
        if(Array.isArray(a.empathy)){
          for(const e of a.empathy){
            const v=e.empathy??e.score??e.value;
            out.push({
              kind:'empathy',
              role:normaliseRole(e.participant||e.participantPurpose),
              startTimeMs:coerceMs(e.startTimeMs),
              endTimeMs:(e.duration?.milliseconds!=null)?(coerceMs(e.startTimeMs)+Number(e.duration.milliseconds)):coerceMs(e.endTimeMs),
              value:(typeof v==='number')?v:labelToScore(v)
            });
          }
        }
      }
      return out.filter(s=>s.role && s.startTimeMs!=null);
    }

    function processPhrases(parsed){
      let phrases=[];
      if(Array.isArray(parsed?.transcripts)){
        parsed.transcripts.forEach(tr=>{ if(Array.isArray(tr.phrases)) phrases=phrases.concat(tr.phrases); });
      }
      if(Array.isArray(parsed?.phrases)) phrases=phrases.concat(parsed.phrases);
      return phrases.map(ph=>{
        const start=coerceMs(ph.startTimeMs??ph.startTime??ph.offsetMs??ph.offset);
        const end=coerceMs(ph.endTimeMs??ph.endTime??(start!=null?start+3000:null));
        const role=normaliseRole(ph.participantPurpose??ph.participant??ph.role);
        const text=ph.decoratedText??ph.text??ph.transcript??'';
        const conf=(typeof ph.confidence==='number')?ph.confidence
                 :(typeof ph.confidenceScore==='number')?ph.confidenceScore
                 :(typeof ph.asrConfidence==='number')?ph.asrConfidence:null;
        const directSent=ph.sentimentScore??ph.sentiment??ph.analytics?.sentiment??null;
        const directEmp =ph.empathyScore??ph.empathy??ph.analytics?.empathy??null;
        return {
          participantPurpose: role||'external',
          decoratedText: text,
          startTimeMs: start ?? 0,
          endTimeMs: end ?? ((start ?? 0)+3000),
          sentimentDirect: labelToScore(directSent),
          empathyDirect: (typeof directEmp==='number')?directEmp:labelToScore(directEmp),
          confidence: (typeof conf==='number'?conf:null),
          participantId: ph.participantId,
          userIds: ph.userIds||[],
          externalContactIds: ph.externalContactIds||[]
        };
      }).filter(p=>p.decoratedText && p.startTimeMs!=null).sort((a,b)=>a.startTimeMs-b.startTimeMs);
    }

    // === Numeric ‚Üí Label thresholds ===
    const SENTIMENT_POS = 0.15;   // > +0.15 = Positive
    const SENTIMENT_NEG = -0.15;  // < -0.15 = Negative
    const EMPATHY_GOOD  = 0.20;   // > +0.20 = Empathetic (else Unhelpful)

    function sentimentToLabel(v){
      if (v == null || isNaN(v)) return {label:'-', css:'sentiment-neutral'};
      if (v > SENTIMENT_POS)     return {label:'Positive', css:'sentiment-positive'};
      if (v < SENTIMENT_NEG)     return {label:'Negative', css:'sentiment-negative'};
      return {label:'Neutral', css:'sentiment-neutral'};
    }
    function empathyToLabel(v){
      if (v == null || isNaN(v)) return {label:'-', css:''};
      return (v > EMPATHY_GOOD)
        ? {label:'Empathetic', css:'empathy-positive'}
        : {label:'Unhelpful',  css:''};
    }

    // ===== Transcript fetch & render =====
    async function getTranscriptForConversation(conversationId){
      const statusEl = document.querySelector('#transcript-status-' + conversationId);
      const container = document.querySelector('#transcript-' + conversationId);
      const btn = document.querySelector('#btn-transcript-' + conversationId);
      if(!state.token){ alert('Not authenticated'); return; }
      const conv = state.convIndex[conversationId]; if(!conv){ statusEl.textContent='Conversation not found in state.'; return; }
      const commId = findCommunicationsIdFromDetails(conv);
      if(!commId){ statusEl.textContent='No sessionId found to use as communicationsId.'; return; }
      try{
        btn.disabled=true; statusEl.textContent='Requesting transcript URL‚Ä¶';
        const urlRes = await fetch(CONFIG.apiHost + '/api/v2/speechandtextanalytics/conversations/' + conversationId + '/communications/' + commId + '/transcripturl', {headers:{Authorization:'Bearer ' + state.token}});
        if(!urlRes.ok){ const t=await res.text().catch(()=> ''); throw new Error('Transcript URL error: ' + urlRes.status + ' ' + urlRes.statusText + (t?' - ' + t.slice(0,200):'')); }
        const {url:presigned} = await urlRes.json(); if(!presigned) throw new Error('No URL in transcript response.');
        statusEl.textContent='Downloading transcript‚Ä¶';
        const raw = await fetch(presigned); if(!raw.ok) throw new Error('Transcript download failed: ' + raw.status + ' ' + raw.statusText);
        const text = await raw.text(); let parsed=null; try{ parsed=JSON.parse(text);}catch{}
        statusEl.textContent='Rendering transcript‚Ä¶';
        renderTranscript(container, parsed, text, conv);
        statusEl.textContent='Transcript loaded.';
      }catch(e){
        console.error(e); statusEl.innerHTML='‚ö†Ô∏è ' + e.message + '<span class="muted"> ‚Äî If this is a CORS issue, try opening the raw URL in a new tab.</span>';
      }finally{ btn.disabled=false; }
    }
    window.getTranscriptForConversation = getTranscriptForConversation;

    // === Anchor sentiment/empathy ONLY to the nearest phrase (¬±1.5s)
    const SIGNAL_ANCHOR_TOL_MS = 1500;

    function renderTranscript(container, parsed, rawText, conversation){
      const escapeHtml = s => (s||'').toString().replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[c]));

      const phrases = processPhrases(parsed);
      const signals = extractSignals(parsed);
      if (!phrases.length){
        container.innerHTML = '<div class="muted">No transcript phrases found.</div>' +
          '<details><summary>Show Raw Data for Debugging</summary><pre>' + escapeHtml(typeof rawText==='string'?rawText:JSON.stringify(parsed,null,2)) + '</pre></details>';
        return;
      }

      // start with a clean slate per phrase
      const enriched = phrases.map(p=>({
        ...p,
        sentiment: (p.sentimentDirect!=null)?Number(p.sentimentDirect):null,
        empathy:   (p.empathyDirect!=null)?Number(p.empathyDirect):null
      }));

      const sentiments = signals.filter(s=>s.kind==='sentiment' && s.role==='external');
      const empathies  = signals.filter(s=>s.kind==='empathy'  && s.role==='internal');

      function assignNearest(signalsArr, role, field){
        for(const s of signalsArr){
          let bestIdx=-1, bestDelta=Infinity;
          for(let i=0;i<enriched.length;i++){
            const p=enriched[i];
            if(p.participantPurpose!==role) continue;
            const d=Math.abs((p.startTimeMs??0) - (s.startTimeMs??0));
            if(d<=SIGNAL_ANCHOR_TOL_MS && d<bestDelta){ bestDelta=d; bestIdx=i; }
          }
          if(bestIdx>=0){
            // only assign if not already set (phrase-level value wins)
            if(enriched[bestIdx][field]==null) enriched[bestIdx][field]=s.value;
          }
        }
      }

      // anchor analytics to *one* phrase per signal
      assignNearest(sentiments,'external','sentiment');
      assignNearest(empathies,'internal','empathy');

      const nameMap = mapParticipantNames(conversation);
      const { internal, external } = participantsByType(conversation);

      function sentimentCell(p){
        if(p.participantPurpose!=='external' || p.sentiment==null) return '-';
        const {label, css} = sentimentToLabel(Number(p.sentiment));
        return `<span class="${css}">${label}</span>`;
      }
      function empathyCell(p){
        if(p.participantPurpose!=='internal' || p.empathy==null) return '-';
        const {label, css} = empathyToLabel(Number(p.empathy));
        return `<span class="${css}">${label}</span>`;
      }
      function confidenceCell(p){
        const v = (p.confidence!=null) ? Number(p.confidence) : null;
        if(v==null || isNaN(v)) return '-';
        const fixed=v.toFixed(3);
        if(v>=0.8) return `<span class="confidence-high">${fixed}</span>`;
        if(v>=0.6) return `<span class="confidence-medium">${fixed}</span>`;
        return `<span class="confidence-low">${fixed}</span>`;
      }
      function displayName(p){
        if(p.participantPurpose==='internal'){
          if(p.userIds && p.userIds.length){
            const id=p.userIds[0];
            return nameMap[id] || (state.users.find(u=>u.id===id)?.name) || internal[0] || 'Agent';
          }
          return internal[0] || 'Agent';
        }
        return external[0] || 'Customer';
      }

      const convStart = new Date(conversation.conversationStart).getTime();

      let html = '<div class="transcript-summary">';
      html += '<div class="t-summary-grid">';
      html += '<div class="t-kv"><span class="k">Interaction Type:</span><span>' + (getConversationMediaTypes(conversation) || 'Voice') + '</span></div>';
      html += '<div class="t-kv"><span class="k">Conversation Start:</span><span>' + fmt(conversation.conversationStart) + '</span></div>';
      html += '<div class="t-kv"><span class="k">Conversation End:</span><span>' + fmt(conversation.conversationEnd) + '</span></div>';
      html += '<div class="t-kv"><span class="k">Interaction ID:</span><span class="mono">' + conversation.conversationId + '</span></div>';
      html += '<div class="t-kv"><span class="k">Duration:</span><span>' + formatSeconds(calculateDuration(conversation.conversationStart, conversation.conversationEnd)) + '</span></div>';
      html += '<div class="t-kv"><span class="k">Direction:</span><span>' + (getDirection(conversation) || 'Unknown') + '</span></div>';
      html += '</div></div>';

      html += '<table class="transcript-table"><thead><tr>';
      html += '<th>Time (MM:SS)</th>';
      html += '<th>Participant Type</th>';
      html += '<th>Participant</th>';
      html += '<th>Participant Text</th>';
      html += '<th>Sentiment</th>';
      html += '<th>Empathy</th>';
      html += '<th>Confidence</th>';
      html += '</tr></thead><tbody>';

      enriched.forEach(p=>{
        const absolute = p.startTimeMs>1e12;
        const rel = absolute ? (p.startTimeMs - convStart) : p.startTimeMs;
        const timeFormatted = mmss(Math.max(0, rel));
        const participantType = p.participantPurpose==='internal' ? 'Internal' : 'External';
        html += '<tr>';
        html += '<td class="mono" style="font-weight:bold;">'+timeFormatted+'</td>';
        html += '<td>'+participantType+'</td>';
        html += '<td>'+escapeHtml(displayName(p))+'</td>';
        html += '<td>'+escapeHtml(p.decoratedText)+'</td>';
        html += '<td>'+sentimentCell(p)+'</td>';
        html += '<td>'+empathyCell(p)+'</td>';
        html += '<td>'+confidenceCell(p)+'</td>';
        html += '</tr>';
      });

      html += '</tbody></table>';

      const customerPhrases = enriched.filter(p=>p.participantPurpose==='external');
      const agentPhrases = enriched.filter(p=>p.participantPurpose==='internal');
      const customerWithSent = customerPhrases.filter(p=>p.sentiment!=null);
      const agentWithEmp = agentPhrases.filter(p=>p.empathy!=null);
      const withConf = enriched.filter(p=>p.confidence!=null);

      html += '<div class="muted" style="margin-top:16px;padding:12px;background:#f8f9fa;border-radius:6px;">';
      html += '<strong>Analytics Summary:</strong><br>';
      html += 'Total phrases: ' + enriched.length + '<br>';
      html += 'Customer phrases with sentiment: ' + customerWithSent.length + '<br>';
      html += 'Agent phrases with empathy: ' + agentWithEmp.length + '<br>';
      html += 'Phrases with confidence: ' + withConf.length + '<br>';
      html += '</div>';

      container.innerHTML = html;
    }

    function mapParticipantNames(conv){
      const map={};
      for(const p of (conv.participants||[])){
        if(p.userId){ const u=state.users.find(x=>x.id===p.userId); map[p.participantId||p.userId] = u?u.name:`Agent (${p.userId})`; }
        else if(p.purpose==='customer'){ map[p.participantId||'customer']='Customer'; }
        else if(p.purpose==='acd'){ const qid=getQueueIdFromParticipant(p); map[p.participantId||qid||'acd']=qid?(getQueueName(qid)||'Queue'):'Queue'; }
      } return map;
    }
    function participantsByType(conv){
      const internal=new Set(), external=new Set();
      for(const p of (conv.participants||[])){
        if(p.userId){ const u=state.users.find(x=>x.id===p.userId); internal.add(u?u.name:`Agent (${p.userId})`); }
        else if(p.purpose==='customer'){ external.add(p.participantName||'Customer'); }
      } return {internal:[...internal], external:[...external]};
    }
    function findCommunicationsIdFromDetails(conv){
      for(const p of (conv.participants||[])) for(const s of (p.sessions||[])) if((s.mediaType||'').toLowerCase()==='voice' && s.sessionId) return s.sessionId;
      for(const p of (conv.participants||[])) for(const s of (p.sessions||[])) if(s.sessionId) return s.sessionId;
      for(const p of (conv.participants||[])) for(const s of (p.sessions||[])) if(s.communicationId) return s.communicationId;
      for(const p of (conv.participants||[])) for(const s of (p.sessions||[])) if(s.id) return s.id;
      return null;
    }

    // ===== Fetch conversations =====
    async function fetchConversations(){
      try{
        if(!state.selectedAgent){ setStatus('Please select an agent first', true); return; }
        const from=$('fromDate').value, to=$('toDate').value||from;
        if(!from){ setStatus('Please select a start date', true); return; }
        const today = new Date().toISOString().split('T')[0];
        if(from > today || to > today) { setStatus('Date range cannot be in the future', true); return; }

        setStatus('Fetching conversations‚Ä¶'); setLoading(true); $('resultsSection').style.display='none';

        const auto=$('autoChunk').checked;
        const days = auto? optimalDays(from,to) : (new Date(to)-new Date(from) >= 0 ? (Math.ceil((new Date(to)-new Date(from))/(1000*60*60*24))+1) : 1);
        const dateChunks = auto? chunks(from,to,days) : [{start:from,end:to}];

        $('chunkInfo').innerHTML = auto
          ? 'Large range: <strong>' + fmtDMY(from) + ' to ' + fmtDMY(to) + '</strong><br>Auto-splitting into <strong>' + dateChunks.length + ' chunks</strong> of ' + days + ' days.'
          : 'Processing range: <strong>' + fmtDMY(from) + ' to ' + fmtDMY(to) + '</strong>';

        showProgress();
        state.conversations=[]; state.convIndex={};

        for(let i=0;i<dateChunks.length;i++){
          const ch=dateChunks[i]; updateProgress((i/dateChunks.length)*100, i+1, dateChunks.length);
          setStatus('Fetching chunk ' + (i+1) + '/' + dateChunks.length + ': ' + ch.start + ' ‚Üí ' + ch.end);
          try{
            const body = { interval: ch.start + 'T00:00:00/' + ch.end + 'T23:59:59', order:'asc', orderBy:'conversationStart', segmentFilters:[{type:'and',predicates:[{type:'dimension',dimension:'userId',operator:'matches',value: state.selectedAgent.id }]}] };
            const res = await fetch(CONFIG.apiHost + '/api/v2/analytics/conversations/details/query', { method:'POST', headers:{Authorization:'Bearer ' + state.token,'Content-Type':'application/json'}, body:JSON.stringify(body) });
            if(!res.ok){ const t=await res.text().catch(()=> ''); throw new Error('Details error: ' + res.status + ' ' + res.statusText + (t?' - ' + t.slice(0,200):'')); }
            const data = await res.json(); const convs = data.conversations||[];
            for(const c of convs) state.convIndex[c.conversationId]=c;
            state.conversations = state.conversations.concat(convs);
          }catch(e){ console.error(e); setStatus('Warning: failed chunk ' + (i+1) + ', continuing‚Ä¶', true); }
          if(i<dateChunks.length-1) await new Promise(r=>setTimeout(r,400));
        }

        await warmQueueCache(state.conversations);

        updateProgress(100, dateChunks.length, dateChunks.length);
        renderResults(state.conversations, from, to);
        setStatus('Found ' + state.conversations.length + ' conversations for the selected period');
        setLoading(false); hideProgress();
      }catch(e){ setStatus('Error fetching conversations: ' + e.message, true); setLoading(false); hideProgress(); }
    }

    function renderResults(conversations, from, to){
      const results=$('results');
      $('dateRange').textContent = fmtDMY(from) + ' to ' + fmtDMY(to||from);
      $('selectedAgent').textContent = state.selectedAgent?.name||'-';
      $('totalConversations').textContent = conversations.length;

      if(!conversations.length){
        results.innerHTML = '<div class="muted" style="text-align:center;padding:40px"><div style="font-size:48px;margin-bottom:12px">üì≠</div><div>No conversations found for ' + (state.selectedAgent?.name||'the selected agent') + '.</div></div>';
        $('resultsSection').style.display='block'; return;
      }

      results.innerHTML = conversations.map(function(conv){
        const participants = conv.participants ? conv.participants.length : 0;
        const media = getConversationMediaTypes(conv);
        const dir = getDirection(conv);
        return '<details><summary><strong>' + conv.conversationId + '</strong> - ' + fmt(conv.conversationStart) + '<span class="muted" style="margin-left:8px;font-size:.9em">(' + participants + ' participants) ‚Ä¢ Media: ' + media + ' ‚Ä¢ Dir: ' + dir + '</span></summary>' + renderConversationDetails(conv) + '</details>';
      }).join('');

      $('resultsSection').style.display='block';
    }

    function renderConversationDetails(conv){
      const mediaType = getMediaType(conv);
      const direction = getDirection(conv);
      const ani = getANI(conv);
      const totalDur = calculateDuration(conv.conversationStart, conv.conversationEnd);
      const transfers = analyzeTransfers(conv);

      let html = '<div class="conversation-header">';
      html += '<div class="info-grid">';
      html += '<div class="info-item"><span class="info-label">Media Type:</span><span class="info-value">' + mediaType + '</span></div>';
      html += '<div class="info-item"><span class="info-label">Customer Number:</span><span class="info-value">' + ani + '</span></div>';
      html += '<div class="info-item"><span class="info-label">Interaction Direction:</span><span class="info-value">' + direction + '</span></div>';
      html += '<div class="info-item"><span class="info-label">Conversation Start:</span><span class="info-value">' + fmt(conv.conversationStart) + '</span></div>';
      html += '<div class="info-item"><span class="info-label">Conversation End:</span><span class="info-value">' + fmt(conv.conversationEnd) + '</span></div>';
      html += '<div class="info-item"><span class="info-label">Duration:</span><span class="info-value">' + formatSeconds(totalDur) + '</span></div>';
      html += '<div class="info-item"><span class="info-label">Transfers (Agent‚ÜíQueue/Agent):</span><span class="info-value"><span class="transfer-count">' + transfers.totalTransfers + '</span></span></div>';
      html += '</div>';

      html += '<div class="transcript-actions" style="display:flex;gap:8px;align-items:center;margin-top:8px">';
      html += '<button id="btn-transcript-' + conv.conversationId + '" onclick="getTranscriptForConversation(\'' + conv.conversationId + '\')">Get Transcript</button>';
      html += '<span id="transcript-status-' + conv.conversationId + '" class="muted"></span>';
      html += '</div>';
      html += '<div id="transcript-' + conv.conversationId + '" style="margin-top:10px;"></div>';
      html += '</div>';

      html += '<h3 style="margin:14px 0 6px;">Customer Journey Timeline</h3>';
      html += '<div class="journey-timeline">';
      html += renderJourneyTimeline(conv, transfers);
      html += '</div>';

      html += '<details><summary>Raw Conversation Data</summary><pre>' + JSON.stringify(conv, null, 2) + '</pre></details>';
      
      return html;
    }

    function renderJourneyTimeline(conv, transferInfo){
      if(!conv.participants || !conv.participants.length) return '<p class="muted">No participant data available</p>';
      const sorted = [...conv.participants].map(function(p){return {p:p,start:getStepStart(p)};})
        .sort(function(a,b){return (a.start?.getTime()??Infinity)-(b.start?.getTime()??Infinity);})
        .map(function(x){return x.p;});

      return sorted.map(function(p,idx){
        const purpose = p.purpose||'unknown';
        const start = getStepStart(p);
        const nextStart = idx<sorted.length-1 ? getStepStart(sorted[idx+1]) : null;
        const queueId = getQueueIdFromParticipant(p);
        const queueName = queueId ? (getQueueName(queueId)||queueId) : null;
        const name = purpose==='acd' ? (queueName?'Queue: ' + queueName:'ACD Queue') : getParticipantName(p);

        let durMs = 0;
        if(p.userId) durMs = getAgentWindow(p).durationMs||0;
        else if(start && nextStart) durMs = Math.max(0, nextStart - start);

        const alertMs = p.userId ? getAlertMsForAgent(p) : null;
        const alertTime = p.userId ? (Math.floor((alertMs||0)/1000) + 's') : 'N/A';

        const transfer = transferInfo.transfers.find(function(t){return t.step===idx;});

        let stepHtml = '<div class="journey-step">';
        stepHtml += '<div class="step-header">Step ' + (idx+1) + ': ' + badge(purpose, name) + (transfer?'<span style="color:#dc2626;margin-left:8px">üîÑ TRANSFERRED</span>':'') + '</div>';
        stepHtml += '<div class="step-details">';
        if(transfer){
          stepHtml += '<div class="transfer-info"><strong>Transfer:</strong> ' + transfer.type + '<br>From: ' + transfer.from + ' ‚Üí To: ' + transfer.to + '<br>Time: ' + fmt(transfer.time) + '</div>';
        }
        stepHtml += '<div class="info-grid">';
        stepHtml += '<div class="info-item"><span class="info-label">Participant Type:</span><span class="info-value">' + getParticipantType(p) + '</span></div>';
        stepHtml += '<div class="info-item"><span class="info-label">Start Time:</span><span class="info-value">' + fmt(start) + '</span></div>';
        if(queueName) stepHtml += '<div class="info-item"><span class="info-label">Queue:</span><span class="info-value">' + queueName + '</span></div>';
        stepHtml += '<div class="info-item"><span class="info-label">Duration:</span><span class="info-value">' + formatSeconds(durMs) + '</span></div>';
        stepHtml += '<div class="info-item"><span class="info-label">Alert Time:</span><span class="info-value">' + alertTime + '</span></div>';
        stepHtml += '<div class="info-item"><span class="info-label">Purpose:</span><span class="info-value">' + purpose + '</span></div>';
        stepHtml += '<div class="info-item"><span class="info-label">Sessions:</span><span class="info-value">' + ((p.sessions&&p.sessions.length)||1) + '</span></div>';
        stepHtml += '</div></div></div>';
        return stepHtml;
      }).join('');
    }

    // ===== Events & Init =====
    $('fetchBtn').addEventListener('click', fetchConversations);
    (function init(){
      const today=new Date(); const weekAgo=new Date(); weekAgo.setDate(today.getDate()-7);
      $('fromDate').value = weekAgo.toISOString().slice(0,10);
      $('toDate').value = today.toISOString().slice(0,10);
      initAuth();
    })();
  </script>
</body>
</html>
